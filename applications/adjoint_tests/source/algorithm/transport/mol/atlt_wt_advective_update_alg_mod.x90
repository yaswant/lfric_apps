!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing handwritten adjoint test for atl_wt_advective_update_alg_mod routines
module atlt_wt_advective_update_alg_mod

  use r_tran_field_mod,                    only : r_tran_field_type
  use field_mod,                           only : field_type
  use function_space_mod,                  only : function_space_type
  use mesh_mod,                            only : mesh_type
  use model_clock_mod,                     only : model_clock_type
  use function_space_collection_mod,       only : function_space_collection
  use finite_element_config_mod,           only : element_order_h,             &
                                                  element_order_v
  use fs_continuity_mod,                   only : W2h, W2v, Wtheta, W2
  use constants_mod,                       only : i_def, r_def, l_def
  use log_mod,                             only : log_event,       &
                                                  LOG_LEVEL_ERROR, &
                                                  LOG_LEVEL_INFO,  &
                                                  LOG_LEVEL_DEBUG, &
                                                  log_scratch_space
  use transport_metadata_collection_mod,   only : transport_metadata_collection
  use transport_metadata_mod,              only : transport_metadata_type
  use transport_enumerated_types_mod,      only : direction_3d
  use transport_enumerated_types_mod,      only : direction_3d, &
                                                  direction_h,  &
                                                  direction_v

  implicit none

  private
  public :: atlt_wt_advective_update_alg
  public :: atlt_hori_wt_update_alg
  public :: atlt_vert_wt_update_alg

  contains

  !=============================================================================
  !> @brief Adjoint test for atl_wt_advective_update_alg.
  !> @details Passes if adjoint is transpose of tangent linear.
  !> Determined by testing the equality of inner products
  !> < Mx, Mx > and < AMx, x >, where M is the tangent linear
  !> and A is the adjoint.
  subroutine atlt_wt_advective_update_alg( mesh, model_clock )

    use atl_wt_advective_update_alg_mod,     only : atl_wt_advective_update_alg
    use tl_wt_advective_update_alg_mod,      only : tl_wt_advective_update_alg

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh
    type(model_clock_type),   intent(in) :: model_clock

    ! Arguments for tl and adj calls
    type(field_type)                       :: rhs
    type(field_type)                       :: adv_field
    type(field_type)                       :: wind
    type(field_type)                       :: ls_wind
    type(field_type)                       :: ls_adv_field
    real(kind=r_def)                       :: dt
    integer(kind=i_def)                    :: direction
    type(transport_metadata_type), pointer :: transport_metadata
    logical(kind=l_def)                    :: final_rk_stage

    ! Copies of input fields used in inner products
    type(field_type)    :: rhs_input
    type(field_type)    :: adv_field_input
    type(field_type)    :: wind_input

    ! Variables for initialising fields
    type(function_space_type), pointer :: vector_space_w2_ptr
    type(function_space_type), pointer :: vector_space_wtheta_ptr
    integer(kind=i_def), parameter     :: ndata = 6_i_def

    ! Inner products
    real(kind=r_def)            :: inner1
    real(kind=r_def)            :: rhs_inner_prod
    real(kind=r_def)            :: rhs_sf
    real(kind=r_def)            :: adv_field_inner_prod
    real(kind=r_def)            :: adv_field_sf
    real(kind=r_def)            :: wind_inner_prod
    real(kind=r_def)            :: wind_sf
    real(kind=r_def)            :: inner2
    real(kind=r_def)            :: rhs_rhs_input_inner_prod
    real(kind=r_def)            :: adv_field_adv_field_input_inner_prod
    real(kind=r_def)            :: wind_wind_input_inner_prod
    real(kind=r_def), parameter :: eps = 1e-30_r_def

    ! Test parameters and variables
    real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
    real(kind=r_def)            :: machine_tol
    real(kind=r_def)            :: relative_diff

    ! Determining time constants
    dt  = real(model_clock%get_seconds_per_step(), r_def)
    if ( dt <= 0.0_r_def ) then
      write( log_scratch_space, * ) "dt cannot be leq 0, found dt = ", dt
      call log_event( log_scratch_space, log_level_error )
    end if

    direction = direction_3d
    transport_metadata => transport_metadata_collection%get_transport_metadata('density')
    final_rk_stage = .false.

    ! Initialising fields
    vector_space_w2_ptr => function_space_collection % get_fs(                 &
        mesh, element_order_h, element_order_v, W2                             &
    )
    vector_space_wtheta_ptr => function_space_collection % get_fs(             &
        mesh, element_order_h, element_order_v, Wtheta                         &
    )

    call rhs % initialise( vector_space = vector_space_wtheta_ptr )
    call adv_field % initialise( vector_space = vector_space_wtheta_ptr )
    call wind % initialise( vector_space = vector_space_w2_ptr )

    call ls_adv_field % initialise( vector_space = vector_space_wtheta_ptr )
    call ls_wind % initialise( vector_space = vector_space_w2_ptr )

    call rhs_input % initialise( vector_space = vector_space_wtheta_ptr )
    call adv_field_input % initialise( vector_space = vector_space_wtheta_ptr )
    call wind_input % initialise( vector_space = vector_space_w2_ptr )

    rhs_inner_prod = 0.0_r_def
    adv_field_inner_prod = 0.0_r_def
    wind_inner_prod = 0.0_r_def

    ! Initialise values and call the tangent-linear alg.
    call invoke( setval_random( rhs ),                   &
                 setval_x( rhs_input, rhs ),             &
                 setval_random( adv_field ),             &
                 setval_x( adv_field_input, adv_field ), &
                 setval_random( wind ),                  &
                 setval_x( wind_input, wind ),           &
                 setval_random( ls_adv_field ),          &
                 setval_random( ls_wind ) )

    ! Tangent linear
    call tl_wt_advective_update_alg( rhs, adv_field, wind,    &
                                     ls_adv_field, ls_wind,   &
                                     dt, direction,           &
                                     transport_metadata, final_rk_stage )

    ! < Mx, Mx >
    call invoke( x_innerproduct_x( rhs_inner_prod, rhs ),             &
                 x_innerproduct_x( adv_field_inner_prod, adv_field ), &
                 x_innerproduct_x( wind_inner_prod, wind ) )

    ! Determining scale factors
    rhs_sf = 1.0_r_def/(rhs_inner_prod + eps)
    adv_field_sf = 1.0_r_def/(adv_field_inner_prod + eps)
    wind_sf = 1.0_r_def/(wind_inner_prod + eps)

    inner1 = 0.0_r_def
    inner1 = inner1 + rhs_inner_prod*rhs_sf
    inner1 = inner1 + adv_field_inner_prod*adv_field_sf
    inner1 = inner1 + wind_inner_prod*wind_sf
    write(log_scratch_space, *) "atlt_wt_advective_update inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "rhs inner product = ", rhs_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "adv_field inner product = ", adv_field_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "wind inner product = ", wind_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    ! Scaling fields
    call invoke( inc_a_times_X( rhs_sf, rhs ),             &
                 inc_a_times_X( adv_field_sf, adv_field ), &
                 inc_a_times_X( wind_sf, wind ) )

    ! Adjoint alg call and inner products
    rhs_rhs_input_inner_prod = 0.0_r_def
    adv_field_adv_field_input_inner_prod = 0.0_r_def
    wind_wind_input_inner_prod = 0.0_r_def

    ! Adjoint
    call atl_wt_advective_update_alg( rhs, adv_field, wind,    &
                                      ls_adv_field, ls_wind,   &
                                      dt, direction,           &
                                      transport_metadata, final_rk_stage )

    ! < AMx, x >
    call invoke( x_innerproduct_y( rhs_rhs_input_inner_prod,             &
                                   rhs,                                  &
                                   rhs_input ),                          &
                 x_innerproduct_y( adv_field_adv_field_input_inner_prod, &
                                   adv_field,                            &
                                   adv_field_input ),                    &
                 x_innerproduct_y( wind_wind_input_inner_prod,           &
                                   wind,                                 &
                                   wind_input ) )

    inner2 = 0.0_r_def
    inner2 = inner2 + rhs_rhs_input_inner_prod
    inner2 = inner2 + adv_field_adv_field_input_inner_prod
    inner2 = inner2 + wind_wind_input_inner_prod

    ! Test the inner-product values for equality, allowing for the precision of the active variables
    machine_tol = SPACING( MAX( ABS( inner1 ), ABS( inner2 ) ) )
    relative_diff = ABS( inner1 - inner2 ) / machine_tol
    if ( relative_diff < overall_tolerance ) then
      write( log_scratch_space, * ) "PASSED tl_wt_advective_update:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write( log_scratch_space, * ) "FAILED tl_wt_advective_update:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine atlt_wt_advective_update_alg

  !=============================================================================
  !> @brief Adjoint test for atl_hori_wt_update_alg.
  !> @details Passes if adjoint is transpose of tangent linear.
  !> Determined by testing the equality of inner products
  !> < Mx, Mx > and < AMx, x >, where M is the tangent linear
  !> and A is the adjoint.
  subroutine atlt_hori_wt_update_alg( mesh, model_clock )

    use wt_advective_update_alg_mod, only : hori_wt_update_alg
    use atl_wt_advective_update_alg_mod, only : atl_hori_wt_update_alg

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh
    type(model_clock_type),   intent(in) :: model_clock

    ! Arguments for tl and adj calls
    type(field_type) :: u_grad_f
    type(field_type) :: wind
    type(field_type) :: ls_field
    type(field_type) :: ls_wind
    type(transport_metadata_type), pointer :: transport_metadata

    ! Copies of input fields used in inner products
    type(field_type) :: advective_input
    type(field_type) :: wind_input

    ! Variables for initialising fields
    type(function_space_type), pointer :: vector_space_w2h_ptr
    type(function_space_type), pointer :: vector_space_wtheta_ptr

    ! Inner products
    real(kind=r_def)            :: advective_inner_prod
    real(kind=r_def)            :: advective_sf
    real(kind=r_def)            :: wind_inner_prod
    real(kind=r_def)            :: wind_sf
    real(kind=r_def)            :: inner1
    real(kind=r_def)            :: advective_advective_input_inner_prod
    real(kind=r_def)            :: wind_wind_input_inner_prod
    real(kind=r_def)            :: inner2
    real(kind=r_def), parameter :: eps = 1e-30_r_def

    ! Test parameters and variables
    real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
    real(kind=r_def)            :: machine_tol
    real(kind=r_def)            :: relative_diff

    transport_metadata => transport_metadata_collection%get_transport_metadata('density')

    vector_space_w2h_ptr => function_space_collection % get_fs(                &
        mesh, element_order_h, element_order_v, W2h                            &
    )
    vector_space_wtheta_ptr => function_space_collection % get_fs(             &
        mesh, element_order_h, element_order_v, Wtheta                         &
    )
    call u_grad_f % initialise(vector_space=vector_space_wtheta_ptr, name='u_grad_f')
    call wind % initialise(vector_space=vector_space_w2h_ptr, name='wind')
    call ls_field % initialise(vector_space=vector_space_wtheta_ptr, name='ls_field')
    call ls_wind % initialise(vector_space=vector_space_w2h_ptr, name='ls_wind')
    call advective_input % initialise(vector_space=vector_space_wtheta_ptr, name='advective_input')
    call wind_input % initialise(vector_space=vector_space_w2h_ptr, name='wind_input')

    advective_inner_prod = 0.0_r_def
    wind_inner_prod = 0.0_r_def

    ! Initialise arguments and call the tangent-linear kernel.
    call invoke( setval_random(u_grad_f), setval_x(advective_input, u_grad_f), &
                 setval_random(wind), setval_x(wind_input, wind),              &
                 setval_random(ls_field),                                      &
                 setval_random(ls_wind) )
    call hori_wt_update_alg( u_grad_f, wind, ls_wind, ls_field, transport_metadata )
    call invoke( x_innerproduct_x(advective_inner_prod, u_grad_f), &
                 x_innerproduct_x(wind_inner_prod, wind) )

    ! Determining scale factors
    advective_sf = 1.0_r_def/(advective_inner_prod + eps)
    wind_sf = 1.0_r_def/(wind_inner_prod + eps)

    inner1 = 0.0_r_def
    inner1 = inner1 + advective_inner_prod*advective_sf
    inner1 = inner1 + wind_inner_prod*wind_sf
    write(log_scratch_space, *) "atlt_hori_wt_update inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "advective inner product = ", advective_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "wind inner product = ", wind_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    ! Scaling fields
    call invoke( inc_a_times_X( advective_sf, u_grad_f ), &
                 inc_a_times_X( wind_sf, wind ) )

    advective_advective_input_inner_prod = 0.0_r_def
    wind_wind_input_inner_prod = 0.0_r_def

    call atl_hori_wt_update_alg( u_grad_f, wind, ls_wind, ls_field, transport_metadata )
    call invoke( x_innerproduct_y(advective_advective_input_inner_prod, u_grad_f, advective_input), &
                 x_innerproduct_y(wind_wind_input_inner_prod, wind, wind_input) )

    inner2 = 0.0_r_def
    inner2 = inner2 + advective_advective_input_inner_prod
    inner2 = inner2 + wind_wind_input_inner_prod

    ! Test the inner-product values for equality, allowing for the precision of the active variables
    machine_tol = spacing( max( abs(inner1), abs(inner2) ) )
    relative_diff = abs(inner1 - inner2) / machine_tol
    if (relative_diff < overall_tolerance) then
      write(log_scratch_space, *) "PASSED tl_hori_wt_update_alg:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write(log_scratch_space, *) "FAILED tl_hori_wt_update_alg:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine atlt_hori_wt_update_alg

  !=============================================================================
  !> @brief Adjoint test for atl_vert_wt_update_alg.
  !> @details Passes if adjoint is transpose of tangent linear.
  !> Determined by testing the equality of inner products
  !> < Mx, Mx > and < AMx, x >, where M is the tangent linear
  !> and A is the adjoint.
  subroutine atlt_vert_wt_update_alg( mesh, model_clock )

    use tl_wt_advective_update_alg_mod, only : tl_vert_wt_update_alg
    use atl_wt_advective_update_alg_mod, only : atl_vert_wt_update_alg

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh
    type(model_clock_type),   intent(in) :: model_clock

    ! Arguments for tl and adj calls
    type(field_type)                       :: u_grad_f
    type(field_type)                       :: wind
    type(field_type)                       :: field
    type(field_type)                       :: ls_wind
    type(field_type)                       :: ls_field
    type(transport_metadata_type), pointer :: transport_metadata
    logical(kind=l_def)                    :: final_rk_stage

    ! Copies of input fields used in inner products
    type(field_type) :: advective_input
    type(field_type) :: wind_input
    type(field_type) :: field_input

    ! Variables for initialising fields
    type(function_space_type), pointer :: vector_space_w2v_ptr
    type(function_space_type), pointer :: vector_space_wtheta_ptr

    ! Inner products
    real(kind=r_def)            :: advective_inner_prod
    real(kind=r_def)            :: advective_sf
    real(kind=r_def)            :: wind_inner_prod
    real(kind=r_def)            :: wind_sf
    real(kind=r_def)            :: field_inner_prod
    real(kind=r_def)            :: field_sf
    real(kind=r_def)            :: inner1
    real(kind=r_def)            :: advective_advective_input_inner_prod
    real(kind=r_def)            :: wind_wind_input_inner_prod
    real(kind=r_def)            :: field_field_input_inner_prod
    real(kind=r_def)            :: inner2
    real(kind=r_def), parameter :: eps = 1e-30_r_def

    ! Test parameters and variables
    real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
    real(kind=r_def)            :: machine_tol
    real(kind=r_def)            :: relative_diff

    final_rk_stage = .false.
    transport_metadata => transport_metadata_collection%get_transport_metadata('density')

    vector_space_w2v_ptr => function_space_collection % get_fs(                &
        mesh, element_order_h, element_order_v, W2v                            &
    )
    vector_space_wtheta_ptr => function_space_collection % get_fs(             &
        mesh, element_order_h, element_order_v, Wtheta                         &
    )
    call u_grad_f % initialise(vector_space=vector_space_wtheta_ptr, name='u_grad_f')
    call wind % initialise(vector_space=vector_space_w2v_ptr, name='wind')
    call field % initialise(vector_space=vector_space_wtheta_ptr, name='field')
    call ls_wind % initialise(vector_space=vector_space_w2v_ptr, name='ls_wind')
    call ls_field % initialise(vector_space=vector_space_wtheta_ptr, name='ls_field')
    call advective_input % initialise(vector_space=vector_space_wtheta_ptr, name='advective_input')
    call wind_input % initialise(vector_space=vector_space_w2v_ptr, name='wind_input')
    call field_input % initialise(vector_space=vector_space_wtheta_ptr, name='field_input')

    advective_inner_prod = 0.0_r_def
    wind_inner_prod = 0.0_r_def
    field_inner_prod = 0.0_r_def

    ! Initialise arguments and call the tangent-linear kernel.
    call invoke( setval_random(u_grad_f), setval_x(advective_input, u_grad_f), &
                 setval_random(wind), setval_x(wind_input, wind),              &
                 setval_random(field), setval_x(field_input, field),           &
                 setval_random(ls_wind),                                       &
                 setval_random(ls_field) )
    call tl_vert_wt_update_alg( u_grad_f, wind, field, ls_wind, ls_field, transport_metadata, final_rk_stage )
    call invoke( x_innerproduct_x(advective_inner_prod, u_grad_f), &
                 x_innerproduct_x(wind_inner_prod, wind),          &
                 x_innerproduct_x(field_inner_prod, field) )

    ! Determining scale factors
    advective_sf = 1.0_r_def/(advective_inner_prod + eps)
    wind_sf = 1.0_r_def/(wind_inner_prod + eps)
    field_sf = 1.0_r_def/(field_inner_prod + eps)

    inner1 = 0.0_r_def
    inner1 = inner1 + advective_inner_prod*advective_sf
    inner1 = inner1 + wind_inner_prod*wind_sf
    inner1 = inner1 + field_inner_prod*field_sf
    write(log_scratch_space, *) "atlt_vert_wt_update inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "advective inner product = ", advective_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "wind inner product = ", wind_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field inner product = ", field_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    ! Scaling fields
    call invoke( inc_a_times_X( advective_sf, u_grad_f ), &
                 inc_a_times_X( wind_sf, wind ), &
                 inc_a_times_X( field_sf, field ) )

    advective_advective_input_inner_prod = 0.0_r_def
    wind_wind_input_inner_prod = 0.0_r_def
    field_field_input_inner_prod = 0.0_r_def

    call atl_vert_wt_update_alg( u_grad_f, wind, field, ls_wind, ls_field, transport_metadata, final_rk_stage )
    call invoke( x_innerproduct_y( advective_advective_input_inner_prod, &
                                   u_grad_f,                             &
                                   advective_input ),                    &
                 x_innerproduct_y( wind_wind_input_inner_prod,           &
                                   wind,                                 &
                                   wind_input ),                         &
                 x_innerproduct_y( field_field_input_inner_prod,         &
                                   field,                                &
                                   field_input ) )

    inner2 = 0.0_r_def
    inner2 = inner2 + advective_advective_input_inner_prod
    inner2 = inner2 + wind_wind_input_inner_prod
    inner2 = inner2 + field_field_input_inner_prod

    ! Test the inner-product values for equality, allowing for the precision of the active variables
    machine_tol = spacing( max( abs(inner1), abs(inner2) ) )
    relative_diff = abs(inner1 - inner2) / machine_tol
    if (relative_diff < overall_tolerance) then
      write(log_scratch_space, *) "PASSED tl_vert_wt_update_alg:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write(log_scratch_space, *) "FAILED tl_vert_wt_update_alg:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine atlt_vert_wt_update_alg

end module atlt_wt_advective_update_alg_mod
