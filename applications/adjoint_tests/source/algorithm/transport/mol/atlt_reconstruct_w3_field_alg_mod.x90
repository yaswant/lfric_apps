!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing handwritten adjoint test for atl_reconstruct_w3_field_alg
module atlt_reconstruct_w3_field_alg_mod

  use field_mod,                           only : field_type
  use function_space_mod,                  only : function_space_type
  use constants_mod,                       only : r_def, i_def, l_def
  use log_mod,                             only : log_event,         &
                                                  log_scratch_space, &
                                                  LOG_LEVEL_INFO,    &
                                                  LOG_LEVEL_DEBUG,   &
                                                  LOG_LEVEL_ERROR
  use mesh_mod,                            only : mesh_type
  use model_clock_mod,                     only : model_clock_type
  use finite_element_config_mod,           only : element_order_h,             &
                                                  element_order_v
  use fs_continuity_mod,                   only : W3
  use function_space_collection_mod,       only : function_space_collection
  use transport_metadata_collection_mod,   only : transport_metadata_collection
  use transport_metadata_mod,              only : transport_metadata_type
  use transport_enumerated_types_mod,      only : direction_3d

  implicit none

  private
  public :: atlt_reconstruct_w3_field_alg
  public :: atlt_vert_w3_reconstruct_alg

  contains

  !=============================================================================
  !> @brief   Adjoint test for atl_reconstruct_w3_field_alg.
  !> @details Passes if adjoint is transpose of tangent linear.
  !>          Determined by testing the equality of inner products <Mx, Mx> and <AMx, x>,
  !>          where M is the tangent linear and A is the adjoint.
  !> @param[in]  mesh         The model mesh
  !> @param[in]  model_clock  The model clock
  subroutine atlt_reconstruct_w3_field_alg( mesh, model_clock )

    use atl_reconstruct_w3_field_alg_mod,    only : atl_reconstruct_w3_field_alg
    use tl_reconstruct_w3_field_alg_mod,     only : tl_reconstruct_w3_field_alg

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh
    type(model_clock_type),   intent(in) :: model_clock

    ! Arguments for tl and adj calls
    type(field_type)        :: field_new
    type(field_type)        :: field_old
    type(field_type)        :: ls_field_old
    integer(kind=i_def)     :: direction
    type(transport_metadata_type), pointer :: transport_metadata
    logical(kind=l_def)     :: final_rk_stage

    ! Copies of input fields used in inner products
    type(field_type)    :: field_new_input
    type(field_type)    :: field_old_input

    ! Variables for initialising fields
    type(function_space_type), pointer :: vector_space_w3_md_ptr
    type(function_space_type), pointer :: vector_space_w3_ptr
    integer(kind=i_def), parameter     :: ndata = 6_i_def

    ! Inner products
    real(kind=r_def)            :: inner1
    real(kind=r_def)            :: field_new_inner_prod
    real(kind=r_def)            :: field_new_sf
    real(kind=r_def)            :: field_old_inner_prod
    real(kind=r_def)            :: field_old_sf
    real(kind=r_def)            :: inner2
    real(kind=r_def)            :: field_new_field_new_input_inner_prod
    real(kind=r_def)            :: field_old_field_old_input_inner_prod
    real(kind=r_def), parameter :: eps = 1e-30_r_def

    ! Test parameters and variables
    real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
    real(kind=r_def)            :: machine_tol
    real(kind=r_def)            :: relative_diff

    direction = direction_3d
    transport_metadata => transport_metadata_collection%get_transport_metadata('density')
    final_rk_stage = .false.

    ! Initialising fields
    vector_space_w3_md_ptr => function_space_collection % get_fs(              &
        mesh, element_order_h, element_order_v, W3, ndata, ndata_first=.false. &
    )
    vector_space_w3_ptr => function_space_collection % get_fs(                 &
        mesh, element_order_h, element_order_v, W3                             &
    )

    call field_new % initialise( vector_space = vector_space_w3_md_ptr )
    call field_old % initialise( vector_space = vector_space_w3_ptr )

    call ls_field_old % initialise( vector_space = vector_space_w3_ptr )

    call field_new_input % initialise( vector_space = vector_space_w3_md_ptr )
    call field_old_input % initialise( vector_space = vector_space_w3_ptr )

    field_new_inner_prod = 0.0_r_def
    field_old_inner_prod = 0.0_r_def

    ! Initialise values and call the tangent-linear alg.
    call invoke( setval_random( field_new ),             &
                 setval_x( field_new_input, field_new ), &
                 setval_random( field_old ),             &
                 setval_x( field_old_input, field_old ), &
                 setval_random( ls_field_old ) )

    ! Tangent linear
    call tl_reconstruct_w3_field_alg( field_new, field_old, ls_field_old, &
                                      direction, transport_metadata, final_rk_stage )

    ! < Mx, Mx >
    call invoke( x_innerproduct_x( field_new_inner_prod, field_new ), &
                 x_innerproduct_x( field_old_inner_prod, field_old ) )

    ! Determining scale factors
    field_new_sf = 1.0_r_def/(field_new_inner_prod + eps)
    field_old_sf = 1.0_r_def/(field_old_inner_prod + eps)

    inner1 = 0.0_r_def
    inner1 = inner1 + field_new_inner_prod*field_new_sf
    inner1 = inner1 + field_old_inner_prod*field_old_sf
    write(log_scratch_space, *) "atlt_reconstruct_w3_field inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field_new inner product = ", field_new_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field_old inner product = ", field_old_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    ! Scaling fields
    call invoke( inc_a_times_X( field_new_sf, field_new ), &
                 inc_a_times_X( field_old_sf, field_old ) )

    ! Adjoint alg call and inner products
    field_new_field_new_input_inner_prod = 0.0_r_def
    field_old_field_old_input_inner_prod = 0.0_r_def

    ! Adjoint
    call atl_reconstruct_w3_field_alg( field_new, field_old, ls_field_old, &
                                       direction, transport_metadata, final_rk_stage )

    ! < AMx, x >
    call invoke( x_innerproduct_y( field_new_field_new_input_inner_prod, &
                                   field_new,                            &
                                   field_new_input ),                    &
                 x_innerproduct_y( field_old_field_old_input_inner_prod, &
                                   field_old,                            &
                                   field_old_input ) )

    inner2 = 0.0_r_def
    inner2 = inner2 + field_new_field_new_input_inner_prod
    inner2 = inner2 + field_old_field_old_input_inner_prod

    ! Test the inner-product values for equality, allowing for the precision of the active variables
    machine_tol = spacing( max( abs(inner1), abs(inner2) ) )
    relative_diff = abs(inner1 - inner2) / machine_tol
    if ( relative_diff < overall_tolerance ) then
      write( log_scratch_space, * ) "PASSED tl_reconstruct_w3_field:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write( log_scratch_space, * ) "FAILED tl_reconstruct_w3_field:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine atlt_reconstruct_w3_field_alg

  !=============================================================================
  !> @brief   Adjoint test for atl_vert_w3_reconstruct_alg.
  !> @details Passes if adjoint is transpose of tangent linear.
  !>          Determined by testing the equality of inner products <Mx, Mx> and <AMx, x>,
  !>          where M is the tangent linear and A is the adjoint.
  !> @param[in]  mesh         The model mesh
  !> @param[in]  model_clock  The model clock
  subroutine atlt_vert_w3_reconstruct_alg( mesh, model_clock )

    use atl_reconstruct_w3_field_alg_mod,    only : atl_vert_w3_reconstruct_alg
    use tl_reconstruct_w3_field_alg_mod,     only : tl_vert_w3_reconstruct_alg

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh
    type(model_clock_type),   intent(in) :: model_clock

    ! Arguments for tl and adj calls
    type(field_type)        :: field_new
    type(field_type)        :: field_old
    type(field_type)        :: ls_field_old
    type(transport_metadata_type), pointer :: transport_metadata
    logical(kind=l_def)     :: final_rk_stage

    ! Copies of input fields used in inner products
    type(field_type)    :: field_new_input
    type(field_type)    :: field_old_input

    ! Variables for initialising fields
    type(function_space_type), pointer :: vector_space_w3_md_ptr
    type(function_space_type), pointer :: vector_space_w3_ptr
    integer(kind=i_def), parameter     :: ndata = 2_i_def

    ! Inner products
    real(kind=r_def)            :: inner1
    real(kind=r_def)            :: field_new_inner_prod
    real(kind=r_def)            :: field_new_sf
    real(kind=r_def)            :: field_old_inner_prod
    real(kind=r_def)            :: field_old_sf
    real(kind=r_def)            :: inner2
    real(kind=r_def)            :: field_new_field_new_input_inner_prod
    real(kind=r_def)            :: field_old_field_old_input_inner_prod
    real(kind=r_def), parameter :: eps = 1e-30_r_def

    ! Test parameters and variables
    real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
    real(kind=r_def)            :: machine_tol
    real(kind=r_def)            :: relative_diff

    transport_metadata => transport_metadata_collection%get_transport_metadata('density')
    final_rk_stage = .false.

    ! Initialising fields
    vector_space_w3_md_ptr => function_space_collection % get_fs(              &
        mesh, element_order_h, element_order_v, W3, ndata, ndata_first=.false. &
    )
    vector_space_w3_ptr => function_space_collection % get_fs(                 &
        mesh, element_order_h, element_order_v, W3                             &
    )

    call field_new % initialise( vector_space = vector_space_w3_md_ptr )
    call field_old % initialise( vector_space = vector_space_w3_ptr )

    call ls_field_old % initialise( vector_space = vector_space_w3_ptr )

    call field_new_input % initialise( vector_space = vector_space_w3_md_ptr )
    call field_old_input % initialise( vector_space = vector_space_w3_ptr )

    field_new_inner_prod = 0.0_r_def
    field_old_inner_prod = 0.0_r_def

    ! Initialise values and call the tangent-linear alg.
    call invoke( setval_random( field_new ),             &
                 setval_x( field_new_input, field_new ), &
                 setval_random( field_old ),             &
                 setval_x( field_old_input, field_old ), &
                 setval_random( ls_field_old ) )

    ! Tangent linear
    call tl_vert_w3_reconstruct_alg( field_new, field_old, ls_field_old, &
                                     transport_metadata, final_rk_stage )

    ! < Mx, Mx >
    call invoke( x_innerproduct_x( field_new_inner_prod, field_new ), &
                 x_innerproduct_x( field_old_inner_prod, field_old ) )

    ! Determining scale factors
    field_new_sf = 1.0_r_def/(field_new_inner_prod + eps)
    field_old_sf = 1.0_r_def/(field_old_inner_prod + eps)

    inner1 = 0.0_r_def
    inner1 = inner1 + field_new_inner_prod*field_new_sf
    inner1 = inner1 + field_old_inner_prod*field_old_sf
    write(log_scratch_space, *) "atlt_vert_w3_reconstruct inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field_new inner product = ", field_new_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field_old inner product = ", field_old_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    ! Scaling fields
    call invoke( inc_a_times_X( field_new_sf, field_new ), &
                 inc_a_times_X( field_old_sf, field_old ) )

    ! Adjoint alg call and inner products
    field_new_field_new_input_inner_prod = 0.0_r_def
    field_old_field_old_input_inner_prod = 0.0_r_def

    ! Adjoint
    call atl_vert_w3_reconstruct_alg( field_new, field_old, ls_field_old, &
                                      transport_metadata, final_rk_stage )

    ! < AMx, x >
    call invoke( x_innerproduct_y( field_new_field_new_input_inner_prod, &
                                   field_new,                            &
                                   field_new_input ),                    &
                 x_innerproduct_y( field_old_field_old_input_inner_prod, &
                                   field_old,                            &
                                   field_old_input ) )

    inner2 = 0.0_r_def
    inner2 = inner2 + field_new_field_new_input_inner_prod
    inner2 = inner2 + field_old_field_old_input_inner_prod

    ! Test the inner-product values for equality, allowing for the precision of the active variables
    machine_tol = spacing( max( abs(inner1), abs(inner2) ) )
    relative_diff = abs(inner1 - inner2) / machine_tol
    if ( relative_diff < overall_tolerance ) then
      write( log_scratch_space, * ) "PASSED tl_vert_w3_reconstruct:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write( log_scratch_space, * ) "FAILED tl_vert_w3_reconstruct:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine atlt_vert_w3_reconstruct_alg

end module atlt_reconstruct_w3_field_alg_mod
