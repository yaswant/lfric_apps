!-------------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------
!> @brief Processes diagnostics relating to the semi-implicit timestep

module si_diagnostics_mod

  use constants_mod,            only: l_def
  use derived_config_mod,       only: bundle_size
  use field_mod,                only: field_type
  use field_collection_mod,     only: field_collection_type
  use field_indices_mod,        only: igh_u, igh_t, igh_p
  use formulation_config_mod,   only: use_physics, moisture_formulation, &
                                      moisture_formulation_dry
  use physics_config_mod,       only: blayer_placement,                 &
                                      blayer_placement_fast,            &
                                      convection_placement,             &
                                      convection_placement_fast,        &
                                      stochastic_physics_placement,     &
                                      stochastic_physics_placement_fast
  use physics_mappings_alg_mod, only: map_physics_winds
  use mr_indices_mod,           only: nummr, imr_v, imr_cl, imr_ci, imr_s
  use timing_mod,               only: start_timing, stop_timing, tik, LPROF

  use initialise_diagnostics_mod, only: init_diag => init_diagnostic_field

  implicit none

  private

  !--------------------------------------------
  ! Flags for mutually dependent 3D diagnostics
  !--------------------------------------------

  logical (l_def) :: du_tot_flag
  logical (l_def) :: dv_tot_flag
  logical (l_def) :: dw_tot_flag
  logical (l_def) :: du_adv_flag
  logical (l_def) :: dv_adv_flag
  logical (l_def) :: dw_adv_flag
  logical (l_def) :: du_solv_flag
  logical (l_def) :: dv_solv_flag
  logical (l_def) :: dw_solv_flag

  public :: output_diags_for_si

contains

  subroutine output_diags_for_si(state, state_n, state_after_slow, mr, mr_n,   &
                                 mr_after_slow, mr_after_adv, derived_fields,  &
                                 du_fast, dtheta_fast, dtheta_cld)

    implicit none

    type(field_type), dimension(bundle_size), intent(in) :: state, state_n, &
                                                            state_after_slow
    type(field_type), dimension(nummr), intent(in) :: mr, mr_n, mr_after_slow, &
                                                      mr_after_adv

    type(field_type), intent(in) :: du_fast, dtheta_fast, dtheta_cld

    type(field_collection_type), intent(in) :: derived_fields

    type(field_type) :: dtheta_tot, du_w2_tot, du_tot, dv_tot, dw_tot,        &
                        dt_solv, t_tmp, dt_tot,                               &
                        dmv_tot, dmcl_tot, dmci_tot, dtheta_adv, dtheta_slow, &
                        du_w2_adv, du_adv, dv_adv, dw_adv, dmv_adv,           &
                        dmcl_adv, dmci_adv,                                   &
                        dtheta_solv, du_w2_solv, du_solv, dv_solv, dw_solv,   &
                        dms_tot, dms_adv

    type(field_type), pointer :: u_star
    type(field_type), pointer :: theta_star
    type(field_type), pointer :: exner_in_wth
    type(field_type), pointer :: exner_wth_n

    logical(l_def) :: ignore
    integer(tik)   :: id

    if ( LPROF ) call start_timing( id, 'diags.dynamics' )

    ! Slow physics timestep theta increments
    ! Difference between state at time step n (X_n) and X_after_slow
    if (init_diag(dtheta_slow, 'processed__dtheta_slow')) then
      call invoke(X_minus_Y(dtheta_slow,state_after_slow(igh_t),state_n(igh_t)))
      call dtheta_slow%write_field('processed__dtheta_slow')
    end if

    ! Total increments
    ! Difference between current value (X) and X_n
    if (init_diag(dtheta_tot, 'processed__dtheta_tot')) then
      call invoke(X_minus_Y(dtheta_tot,state(igh_t),state_n(igh_t)))
      call dtheta_tot%write_field('processed__dtheta_tot')
    end if

    if (init_diag(dt_tot, 'processed__dt_tot')) then
      call derived_fields%get_field('exner_in_wth', exner_in_wth)
      call derived_fields%get_field('exner_wth_n', exner_wth_n)
      call dt_tot%copy_field_properties(t_tmp)
      call invoke(X_times_Y(dt_tot, state(igh_t), exner_in_wth), &
                  X_times_Y(t_tmp, state_n(igh_t), exner_wth_n), &
                  inc_X_minus_Y(dt_tot, t_tmp) )
      call dt_tot%write_field('processed__dt_tot')
    end if

    du_tot_flag = init_diag(du_tot, 'processed__du_tot')
    dv_tot_flag = init_diag(dv_tot, 'processed__dv_tot')
    dw_tot_flag = init_diag(dw_tot, 'processed__dw_tot')
    ! If any of the three fields is required then all are needed to do the mapping
    if (du_tot_flag .or. dv_tot_flag .or. dw_tot_flag) then
      if (.not. du_tot_flag) ignore = init_diag(du_tot, 'processed__du_tot', activate=.true.)
      if (.not. dv_tot_flag) ignore = init_diag(dv_tot, 'processed__dv_tot', activate=.true.)
      if (.not. dw_tot_flag) ignore = init_diag(dw_tot, 'processed__dw_tot', activate=.true.)
      call state(igh_u)%copy_field_properties(du_w2_tot)
      call invoke(X_minus_Y(du_w2_tot,state(igh_u),state_n(igh_u)))
      call map_physics_winds(du_tot,dv_tot,dw_tot,du_w2_tot)
    end if
    if (du_tot_flag) call du_tot%write_field()
    if (dv_tot_flag) call dv_tot%write_field()
    if (dw_tot_flag) call dw_tot%write_field()

    if (init_diag(dmv_tot, 'processed__dmv_tot')) then
      call invoke(X_minus_Y(dmv_tot,mr(imr_v),mr_n(imr_v)))
      call dmv_tot%write_field()
    end if

    if (init_diag(dmcl_tot, 'processed__dmcl_tot')) then
      call invoke(X_minus_Y(dmcl_tot,mr(imr_cl),mr_n(imr_cl)))
      call dmcl_tot%write_field()
    end if

    if (init_diag(dmci_tot, 'processed__dmci_tot')) then
      call invoke(X_minus_Y(dmci_tot,mr(imr_ci),mr_n(imr_ci)))
      call dmci_tot%write_field()
    end if

    if (init_diag(dms_tot, 'processed__dms_tot')) then
      call invoke(X_minus_Y(dms_tot,mr(imr_s),mr_n(imr_s)))
      call dms_tot%write_field()
    end if

    ! These diagnostics use the predictor values, hence only make sense with
    ! physics on
    if (use_physics .and.                                                       &
             (blayer_placement == blayer_placement_fast .or.                    &
             convection_placement == convection_placement_fast .or.             &
             stochastic_physics_placement == stochastic_physics_placement_fast) &
       ) then

      ! Advection increments
      ! Difference between X_after_adv or X_star and X_after_slow
      if (init_diag(dtheta_adv, 'advection__dtheta_adv')) then
        call derived_fields%get_field('theta_star', theta_star)
        call invoke(X_minus_Y(dtheta_adv,theta_star,state_after_slow(igh_t)))
        call dtheta_adv%write_field()
      end if

      du_adv_flag = init_diag(du_adv, 'advection__du_adv')
      dv_adv_flag = init_diag(dv_adv, 'advection__dv_adv')
      dw_adv_flag = init_diag(dw_adv, 'advection__dw_adv')
      ! If any of the three fields is required then all are needed to do the mapping
      if (du_adv_flag .or. dv_adv_flag .or. dw_adv_flag) then
        call derived_fields%get_field('u_star', u_star)
        if (.not. du_adv_flag) ignore = init_diag(du_adv, 'advection__du_adv', activate=.true.)
        if (.not. dv_adv_flag) ignore = init_diag(dv_adv, 'advection__dv_adv', activate=.true.)
        if (.not. dw_adv_flag) ignore = init_diag(dw_adv, 'advection__dw_adv', activate=.true.)
        call state(igh_u)%copy_field_properties(du_w2_adv)
        call invoke(X_minus_Y(du_w2_adv,u_star,state_after_slow(igh_u)))
        call map_physics_winds(du_adv,dv_adv,dw_adv,du_w2_adv)
      end if
      if (du_adv_flag) call du_adv%write_field()
      if (dv_adv_flag) call dv_adv%write_field()
      if (dw_adv_flag) call dw_adv%write_field()

      if (moisture_formulation /= moisture_formulation_dry) then
       if (init_diag(dmv_adv, 'advection__dmv_adv')) then
          call invoke(X_minus_Y(dmv_adv,mr_after_adv(imr_v),mr_after_slow(imr_v)))
          call dmv_adv%write_field()
        end if

        if (init_diag(dmcl_adv, 'advection__dmcl_adv')) then
          call invoke(X_minus_Y(dmcl_adv,mr_after_adv(imr_cl),mr_after_slow(imr_cl)))
          call dmcl_adv%write_field()
        end if

        if (init_diag(dmci_adv, 'advection__dmci_adv')) then
          call invoke(X_minus_Y(dmci_adv,mr_after_adv(imr_ci),mr_after_slow(imr_ci)))
          call dmci_adv%write_field()
        end if

        if (init_diag(dms_adv, 'advection__dms_adv')) then
          call invoke(X_minus_Y(dms_adv,mr_after_adv(imr_s),mr_after_slow(imr_s)))
          call dms_adv%write_field()
        end if
      end if

      ! Solver increments
      ! Difference between solver value (X-dX_cld) and X_star+dX_fast_physics
      if (init_diag(dtheta_solv, 'solver__dtheta_solv')) then
        call derived_fields%get_field('theta_star', theta_star)
        call invoke(X_minus_Y(dtheta_solv,state(igh_t),theta_star), &
                inc_X_minus_Y(dtheta_solv,dtheta_fast), &
                inc_X_minus_Y(dtheta_solv,dtheta_cld))
        call dtheta_solv%write_field()
      end if

      if (init_diag(dt_solv, 'solver__dt_solv')) then
        call derived_fields%get_field('theta_star', theta_star)
        call derived_fields%get_field('exner_in_wth', exner_in_wth)
        call derived_fields%get_field('exner_wth_n', exner_wth_n)
        call dt_solv%copy_field_properties(t_tmp)
        call invoke(X_minus_Y(dt_solv, state(igh_t), dtheta_cld),   &
                    inc_X_times_Y(dt_solv, exner_in_wth),           &
                    X_plus_Y(t_tmp, theta_star, dtheta_fast),       &
                    inc_X_times_Y(t_tmp, exner_wth_n),              &
                    inc_X_minus_Y(dt_solv, t_tmp) )
        call dt_solv%write_field('solver__dt_solv')
      end if

      du_solv_flag = init_diag(du_solv, 'solver__du_solv')
      dv_solv_flag = init_diag(dv_solv, 'solver__dv_solv')
      dw_solv_flag = init_diag(dw_solv, 'solver__dw_solv')
      if (du_solv_flag .or. dv_solv_flag .or. dw_solv_flag) then
        call derived_fields%get_field('u_star', u_star)
        if (.not. du_solv_flag) ignore = init_diag(du_solv, 'solver__du_solv', activate=.true.)
        if (.not. dv_solv_flag) ignore = init_diag(dv_solv, 'solver__dv_solv', activate=.true.)
        if (.not. dw_solv_flag) ignore = init_diag(dw_solv, 'solver__dw_solv', activate=.true.)
        call state(igh_u)%copy_field_properties(du_w2_solv)
        call invoke(X_minus_Y(du_w2_solv,state(igh_u),u_star), &
                inc_X_minus_Y(du_w2_solv,du_fast))
        call map_physics_winds(du_solv,dv_solv,dw_solv,du_w2_solv)
      end if
      if (du_solv_flag) call du_solv%write_field()
      if (dv_solv_flag) call dv_solv%write_field()
      if (dw_solv_flag) call dw_solv%write_field()
    end if

    if ( LPROF ) call stop_timing( id, 'diags.dynamics' )

  end subroutine output_diags_for_si

end module si_diagnostics_mod
