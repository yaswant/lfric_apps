!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Algorithm to compute various conserved quantities
!>@details Computes various conserved quantities and checks how
!> accurately they have been conserved
module conservation_algorithm_mod

  use compute_total_aam_kernel_mod,    only: compute_total_aam_kernel_type
  use compute_total_mass_alg_mod,      only: compute_total_mass_alg
  use compute_energetics_kernel_mod,   only: compute_energetics_kernel_type
  use compute_entropy_kernel_mod,      only: compute_entropy_kernel_type

  use constants_mod,                   only: r_def, i_def, i_timestep
  use energy_correction_config_mod,    only: integral_method_fe
  use function_space_collection_mod,   only: function_space_collection
  use field_parent_mod,                only: write_interface
  use field_mod,                       only: field_type
  use fs_continuity_mod,               only: W3
  use function_space_mod,              only: function_space_type
  use log_mod,                         only: log_event,         &
                                             log_scratch_space, &
                                             LOG_LEVEL_INFO
  use lfric_xios_write_mod,            only: write_field_generic
  use mesh_mod,                        only: mesh_type
  use quadrature_xyoz_mod,             only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,    only: quadrature_rule_gaussian_type
  use dycore_constants_mod,            only: get_geopotential
  use sci_geometric_constants_mod,     only: get_coordinates, &
                                             get_panel_id
  use io_config_mod,                   only: use_xios_io
  use planet_config_mod,               only: scaled_omega, cv, gravity
  use mr_indices_mod,                  only: nummr
  use timing_mod,                      only: start_timing, stop_timing, &
                                             tik, LPROF
  use initialise_diagnostics_mod,      only: diagnostic_to_be_sampled
  use extrusion_config_mod,            only: planet_radius

  implicit none

  private
  public :: conservation_algorithm

contains

  !>@brief Algorithm to compute various conserved quantities
  !>@details Computes various conserved quantities and checks how
  !> accurately they have been conserved
  !> @param[in] rho Density field
  !> @param[in] u Velocity field
  !> @param[in] theta Potential temperature field
  !> @param[in] mr Water mixing ratio fields
  !> @param[in] exner Exner pressure field
  subroutine conservation_algorithm( rho,          &
                                     u,            &
                                     theta,        &
                                     mr,           &
                                     exner)

    implicit none

    ! Prognostic fields
    type( field_type ), intent( in ) :: u, rho, theta, exner
    type( field_type ), intent( in ) :: mr(nummr)

    ! Local variables
    type( field_type ), pointer :: geopotential => null()
    type( quadrature_xyoz_type ) :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule
    integer(kind=i_def) :: element_order_h, element_order_v
    integer(kind=i_def) :: nqp_h_exact, nqp_v_exact
    ! Coordinate fields
    type( field_type ), pointer :: chi(:) => null()
    type( field_type ), pointer :: panel_id => null()

    type(function_space_type), pointer :: w3_fs => null()

    type( field_type ) :: aam, kinetic_uv, kinetic_w, &
                          potential, internal, moist_int
    type( field_type ) :: entropy_phys_dry, entropy_dyn_dry

    real(kind=r_def) :: total_mass, total_aam, total_energy, &
                        total_kinetic_uv, total_kinetic_w,   &
                        total_potential, total_internal,     &
                        total_moist_int
    real(kind=r_def) :: total_entropy_phys_dry, &
                        total_entropy_dyn_dry,  &
                        surface_geopotential
    type(mesh_type), pointer :: mesh => null()
    integer(tik)             :: id

    procedure(write_interface), pointer :: write_behaviour => null()

    if ( LPROF ) call start_timing( id, 'diags.conservation' )

    element_order_h = rho%get_element_order_h()
      element_order_v = rho%get_element_order_v()
    nqp_h_exact = element_order_h + 3
    nqp_v_exact = element_order_v + 3

    ! Get a quadrature rule
    qr = quadrature_xyoz_type(nqp_h_exact, nqp_h_exact, nqp_v_exact, &
                              quadrature_rule)
    mesh => rho%get_mesh()
    w3_fs => function_space_collection%get_fs( mesh, element_order_h, &
                                               element_order_v, W3 )

    geopotential => get_geopotential(mesh%get_id())
    chi          => get_coordinates(mesh%get_id())
    panel_id     => get_panel_id(mesh%get_id())

    surface_geopotential = planet_radius*gravity


    ! Initialise Mass, Energy and Axial Angular Momentum fields
    call kinetic_uv%initialise( vector_space = w3_fs )
    call kinetic_w%initialise( vector_space = w3_fs )
    call potential%initialise( vector_space = w3_fs )
    call internal%initialise( vector_space = w3_fs )
    call moist_int%initialise( vector_space = w3_fs )
    call aam%initialise( vector_space = w3_fs )
    call entropy_phys_dry%initialise( vector_space = w3_fs )
    call entropy_dyn_dry%initialise( vector_space = w3_fs )

    ! Compute conserved quantities
    call compute_total_mass_alg(total_mass, rho, mesh, method=integral_method_fe)
    call invoke( name = "compute_conserved_quantities",                   &
    ! Compute Energy components
                 compute_energetics_kernel_type(kinetic_uv, kinetic_w,    &
                                                potential, internal,      &
                                                moist_int,                &
                                                u, rho, exner, theta, mr, &
                                                geopotential,             &
                                                surface_geopotential, chi,&
                                                panel_id, cv, qr),        &
                 sum_X(total_kinetic_uv, kinetic_uv),                     &
                 sum_X(total_kinetic_w, kinetic_w),                       &
                 sum_X(total_potential, potential),                       &
                 sum_X(total_internal, internal),                         &
                 sum_X(total_moist_int, moist_int),                       &
    ! Compute (dry) Entropy (physical and dynamic)
                 compute_entropy_kernel_type(entropy_phys_dry,            &
                                             entropy_dyn_dry,             &
                                             rho, theta, chi,             &
                                             panel_id, qr),               &
                 sum_X(total_entropy_phys_dry, entropy_phys_dry),         &
                 sum_X(total_entropy_dyn_dry, entropy_dyn_dry),           &
    ! Compute Total Axial Angular Momentum
                 compute_total_aam_kernel_type(aam, u, rho, chi,          &
                                               panel_id, scaled_omega,    &
                                               qr),                       &
                 sum_X(total_aam, aam) )

    total_energy = total_kinetic_uv + total_kinetic_w + total_potential &
                 + total_internal

    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: dry mass ', total_mass
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: total energy ', total_energy
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: horizontal kinetic energy ', total_kinetic_uv
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: vertical kinetic energy ', total_kinetic_w
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: potential energy ', total_potential
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: dry internal energy ', total_internal
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: moist internal energy ', total_moist_int
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: dry aam ', total_aam
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: dry physical entropy ', total_entropy_phys_dry
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A, E32.24)') &
          'Conservation: dry dynamic entropy ', total_entropy_dyn_dry
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

    if ( use_xios_io ) then

      ! Set write behaviour of fields to output
      write_behaviour => write_field_generic

      ! Write KE and AAM fields
      if (diagnostic_to_be_sampled('ke_uv_in_w3')) then
            call kinetic_uv%set_write_behaviour(write_behaviour)
            call kinetic_uv%write_field('ke_uv_in_w3')
      end if
      if (diagnostic_to_be_sampled('ke_w_in_w3')) then
            call kinetic_w%set_write_behaviour(write_behaviour)
            call kinetic_w%write_field('ke_w_in_w3')
      end if
      if (diagnostic_to_be_sampled('aam_in_w3')) then
            call aam%set_write_behaviour(write_behaviour)
            call aam%write_field('aam_in_w3')
      end if

    end if

    nullify( geopotential )
    nullify( chi, panel_id, w3_fs, mesh )
    nullify ( write_behaviour )

    if ( LPROF ) call stop_timing( id, 'diags.conservation' )

  end subroutine conservation_algorithm

end module conservation_algorithm_mod
