!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains routine for transporting a field collection of tracers.

module tracer_collection_transport_mod

  use constants_mod,                  only: r_def, i_def, r_tran
  use extrusion_mod,                  only: SHIFTED
  use field_mod,                      only: field_type
  use field_parent_mod,               only: field_parent_type
  use r_tran_field_mod,               only: r_tran_field_type
  use field_collection_mod,           only: field_collection_type
  use field_collection_iterator_mod,  only: field_collection_iterator_type
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use log_mod,                        only: log_event,                         &
                                            LOG_LEVEL_ERROR,                   &
                                            LOG_LEVEL_DEBUG
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use transport_controller_mod,       only: transport_controller_type
  use transport_enumerated_types_mod, only: equation_form_advective,           &
                                            equation_form_conservative,        &
                                            equation_form_consistent
  use transport_field_mod,            only: transport_field
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_rho_times_field_alg_mod,    &
                                      only: transport_rho_times_field_alg

  use sci_enforce_lower_bound_kernel_mod,   &
                                      only: enforce_lower_bound_kernel_type

  implicit none

  private

  public :: tracer_collection_transport_alg
  public :: coarse_collection_transport_alg

contains

  !> @brief Central routine for transporting a field collection of tracers.
  !> @details Performs a whole transport time step for a field collection of
  !!          tracers, for instance the cloud fields.
  !> @param[in,out] fields_out         Tracer field collection after transport
  !> @param[in]     fields_in          Tracer field collection before transport
  !> @param[in,out] transport_controller
  !!                                   Encapsulating object containing the
  !!                                   transport counter and precomputations
  !> @param[in,out] transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine tracer_collection_transport_alg(fields_out, fields_in,            &
                                             transport_controller,             &
                                             transport_metadata)

    implicit none

    ! Arguments
    type(field_collection_type),     intent(inout) :: fields_out
    type(field_collection_type),     intent(in)    :: fields_in
    type(transport_controller_type), intent(inout) :: transport_controller
    type(transport_metadata_type),   intent(inout) :: transport_metadata

    ! Iterator for field collection
    type(field_collection_iterator_type) :: iterator

    ! One of the single fields out of the fields_out collection
    type(field_type),            pointer :: single_field_out

    ! The saved version of field after slow physics
    class(field_parent_type),    pointer :: abstract_field_ptr
    type(field_type),            pointer :: single_field_in

    integer(kind=i_def) :: equation_form

    ! If performing advective transport in the first outer loop, then the
    ! transport metadata needs setting here to make that choice
    ! The transport metadata will then be reset correctly within transport_field
    call transport_controller%before_transport_field(transport_metadata)
    equation_form = transport_metadata%get_equation_form()

    if ( fields_in%get_length() > 0 ) then

      call iterator%initialise( fields_in )

      do
        if ( .not. iterator%has_next() ) exit

        abstract_field_ptr => iterator%next()
        select type(abstract_field_ptr)
        type is (field_type)
          single_field_in => abstract_field_ptr
        end select

        call fields_out%get_field(                                             &
                trim(single_field_in%get_name()), single_field_out             &
        )

        call log_event(                                                        &
                "Advecting "//  trim(single_field_in%get_name()),              &
                LOG_LEVEL_DEBUG                                                &
        )

        ! -------------------------------------------------------------------- !
        ! Transport depending on equation
        ! If the equation form is advective:
        !       Simply transport field in native space
        ! If the equation form is consistent:
        !       Requires transformation to densities and evaluation of fluxes.
        !       This is done in the lowest level algorithms, so can just call
        !       transport_field.
        ! If the equation form is conservative:
        !       This also requires transformation to densities and evaluation
        !       of fluxes, but is achieved using the transport_rho_times_field
        !       algorithm (this also divides the result by density at the end
        !       of the transport step and so returns an updated field.)
        ! -------------------------------------------------------------------- !
        select case ( equation_form )

        ! -------------------------------------------------------------------- !
        ! Advective and consistent forms of transport equation
        ! -------------------------------------------------------------------- !
        case ( equation_form_advective, equation_form_consistent )

          call transport_field(                                                &
                  single_field_out, single_field_in, transport_controller,     &
                  transport_metadata                                           &
          )

        ! -------------------------------------------------------------------- !
        ! Conservative form of transport equation
        ! -------------------------------------------------------------------- !
        case ( equation_form_conservative )

          call transport_rho_times_field_alg(                                  &
                  single_field_out, single_field_in, transport_controller,     &
                  transport_metadata                                           &
          )

        ! -------------------------------------------------------------------- !
        ! Default form of transport equation
        ! -------------------------------------------------------------------- !
        case default
          call log_event(                                                      &
                  'Form of tracer collection transport equation either ' //    &
                  'not compatible or not implemented', LOG_LEVEL_ERROR         &
          )

        end select
      end do ! if ( .not. iterator%has_next() ) exit
    end if ! fields_in%get_length() > 0

    ! Reset the transport metadata. This is done at the end of transport_field,
    ! but in case there are no fields in the collection, also reset it here
    call transport_controller%after_transport_field()

  end subroutine tracer_collection_transport_alg


  !> @brief Transports a collection of tracers on a coarser mesh.
  !> @details Performs a whole transport time step for a field collection of
  !!          tracers, mapping them first to a coarser mesh.
  !> @param[in,out] fields_out         Tracer field collection after transport
  !> @param[in]     fields_in          Tracer field collection before transport
  !> @param[in,out] transport_controller
  !!                                   Encapsulating object containing the
  !!                                   transport counter and precomputations
  !> @param[in,out] transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine coarse_collection_transport_alg(fields_out, fields_in,            &
                                             transport_controller,             &
                                             transport_metadata)

    use transport_constants_mod,       only: get_element_order_h_transport, &
                                             get_element_order_v_transport
    use function_space_collection_mod, only: function_space_collection
    use function_space_mod,            only: function_space_type
    use intermesh_mappings_alg_mod,    only: map_scalar_intermesh
    use mesh_collection_mod,           only: mesh_collection
    use mesh_mod,                      only: mesh_type
    use multires_coupling_config_mod,  only: aerosol_mesh_name

    implicit none

    ! Arguments
    type(field_collection_type),     intent(inout) :: fields_out
    type(field_collection_type),     intent(in)    :: fields_in
    type(transport_controller_type), intent(inout) :: transport_controller
    type(transport_metadata_type),   intent(inout) :: transport_metadata

    ! Iterator for field collection
    type(field_collection_iterator_type) :: iterator

    ! One of the single fields out of the fields_out collection
    class(field_parent_type),    pointer :: abstract_field_ptr
    type(field_type),            pointer :: single_field_out

    ! The saved version of field after slow physics
    type(field_type),            pointer :: single_field_in

    ! Coarse mesh objects
    type(mesh_type),             pointer :: coarse_mesh
    type(function_space_type),   pointer :: coarse_fs
    type(field_type)                     :: coarse_field_in, coarse_field_out

    ! Transport runtime and form of transport equation
    integer(kind=i_def) :: equation_form

    ! If performing advective transport in the first outer loop, then the
    ! transport metadata needs setting here to make that choice
    call transport_controller%before_transport_field(transport_metadata)
    equation_form = transport_metadata%get_equation_form()

    if ( fields_in%get_length() > 0 ) then

      call iterator%initialise( fields_in )

      do
        if ( .not. iterator%has_next() ) exit

        abstract_field_ptr => iterator%next()
        select type(abstract_field_ptr)
        type is (field_type)
          single_field_in => abstract_field_ptr
        end select

        call fields_out%get_field(                                             &
                trim(single_field_in%get_name()), single_field_out             &
        )
        call log_event(                                                        &
                "Advecting "//  trim(single_field_in%get_name()),              &
                LOG_LEVEL_DEBUG                                                &
        )

        coarse_mesh => mesh_collection%get_mesh(aerosol_mesh_name)
        coarse_fs => function_space_collection%get_fs(                         &
            coarse_mesh,                                                       &
            get_element_order_h_transport(),                                   &
            get_element_order_v_transport(),                                   &
            single_field_in%which_function_space()                             &
        )
        call coarse_field_in%initialise(coarse_fs)
        call coarse_field_out%initialise(coarse_fs)

        ! Map to coarse mesh ------------------------------------------------- !
        call map_scalar_intermesh(coarse_field_in, single_field_in)

        ! Choose form of transport equation
        select case ( equation_form )

        ! -------------------------------------------------------------------- !
        ! Advective and consistent forms of transport equation
        ! -------------------------------------------------------------------- !
        case ( equation_form_advective, equation_form_consistent )

          ! Transport on coarse mesh ----------------------------------------- !
          call transport_field(                                                &
                  coarse_field_out, coarse_field_in, transport_controller,     &
                  transport_metadata                                           &
          )

        ! -------------------------------------------------------------------- !
        ! Conservative form of transport equation
        ! -------------------------------------------------------------------- !
        case ( equation_form_conservative )

          ! Transport on coarse mesh ----------------------------------------- !
          call transport_rho_times_field_alg(                                  &
                  coarse_field_out, coarse_field_in, transport_controller,     &
                  transport_metadata                                           &
          )

        ! -------------------------------------------------------------------- !
        ! Default form of transport equation
        ! -------------------------------------------------------------------- !
        case default
          call log_event(                                                      &
                  'Form of tracer collection transport equation either ' //    &
                  'not compatible or not implemented',                         &
                  LOG_LEVEL_ERROR                                              &
          )

        end select

        ! Map to dynamics mesh ----------------------------------------------- !
        call map_scalar_intermesh(single_field_out, coarse_field_out)

      end do

    end if

  end subroutine coarse_collection_transport_alg

end module tracer_collection_transport_mod
