!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module controlling the transport of gungho's prognostic variables.

module gungho_transport_control_alg_mod

  use constants_mod,                     only: i_def, r_def, l_def, r_tran, &
                                               PRECISION_R_TRAN
  use extrusion_mod,                     only: SHIFTED
  use field_mod,                         only: field_type
  use flux_precomputations_alg_mod,      only: flux_precomputations_type
  use formulation_config_mod,            only: moisture_formulation,     &
                                               moisture_formulation_dry, &
                                               use_multires_coupling
  use local_mesh_mod,                    only: local_mesh_type
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_DEBUG,   &
                                               LOG_LEVEL_ERROR,   &
                                               LOG_LEVEL_ALWAYS
  use mesh_collection_mod,               only: mesh_collection
  use mesh_mod,                          only: mesh_type
  use multires_coupling_config_mod,      only: coarse_aerosol_transport, &
                                               aerosol_mesh_name
  use r_tran_field_mod,                  only: r_tran_field_type
  use transport_config_mod,              only: transport_ageofair
  use transport_controller_mod,          only: transport_controller_type
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_metadata_collection_mod, only: transport_metadata_collection_type, &
                                               transport_metadata_collection
  use check_configuration_mod,           only: check_any_shifted,    &
                                               check_transport_name, &
                                               check_any_eqn_consistent
  use timing_mod,                        only: start_timing, stop_timing, &
                                               tik, LPROF

  implicit none

  private

  ! Contained suroutines
  public :: gungho_transport_control_alg_init
  public :: gungho_transport_control_alg
  public :: gungho_transport_control_alg_final

contains

  !=============================================================================
  !> @brief Create all the initialisation structures required for transport in
  !!        the model.
  !> @params[in] mesh   The mesh to initialise on
  subroutine gungho_transport_control_alg_init( mesh )

    use transport_config_mod,         only: profile_size,            &
                                            field_names,             &
                                            equation_form,           &
                                            scheme,                  &
                                            splitting,               &
                                            horizontal_method,       &
                                            vertical_method,         &
                                            enforce_min_value,       &
                                            min_value,               &
                                            log_space,               &
                                            reversible,              &
                                            horizontal_monotone,     &
                                            vertical_monotone,       &
                                            vertical_monotone_order, &
                                            special_edges_monotone,  &
                                            ffsl_splitting,          &
                                            ffsl_vertical_order

    implicit none

    type(mesh_type), pointer, intent(in) :: mesh

    integer(kind=i_def)           :: config
    type(transport_metadata_type) :: transport_metadata

    integer(kind=i_def), allocatable :: local_mesh_ids(:)
    type(mesh_type),         pointer :: aerosol_mesh
    type(local_mesh_type),   pointer :: local_mesh

    write(log_scratch_space,'(A)')                               &
        'Transport scheme built with '//trim(PRECISION_R_TRAN)// &
        '-bit real numbers'
    call log_event( log_scratch_space, LOG_LEVEL_ALWAYS )

    ! Set up linked list of metadatas
    transport_metadata_collection = transport_metadata_collection_type()

    ! Set up configs using namelist entries
    do config = 1, profile_size

      write(log_scratch_space,'(3A)') 'Setting up ',trim(field_names(config)),' transport metadata'
      call log_event(log_scratch_space, LOG_LEVEL_DEBUG)

      ! Set hardwired defaults based upon which field is being advected

      transport_metadata = transport_metadata_type( field_names(config),             &
                                                    equation_form(config),           &
                                                    splitting(config),               &
                                                    scheme(config),                  &
                                                    horizontal_method(config),       &
                                                    vertical_method(config),         &
                                                    horizontal_monotone(config),     &
                                                    vertical_monotone(config),       &
                                                    vertical_monotone_order(config), &
                                                    special_edges_monotone(config),  &
                                                    enforce_min_value(config),       &
                                                    real(min_value(config), r_tran), &
                                                    log_space(config),               &
                                                    reversible(config),              &
                                                    ffsl_splitting(config),          &
                                                    ffsl_vertical_order(config) )

      call transport_metadata_collection%set_transport_metadata(transport_metadata)

    end do

    local_mesh => mesh%get_local_mesh()
    if ( use_multires_coupling .and. coarse_aerosol_transport ) then
      ! Need two transport runtimes
      allocate(local_mesh_ids(2))
      local_mesh_ids(1) = local_mesh%get_id()
      aerosol_mesh => mesh_collection%get_mesh(aerosol_mesh_name)
      local_mesh => aerosol_mesh%get_local_mesh()
      local_mesh_ids(2) = local_mesh%get_id()
    else
      ! No coarse transport, so only one transport runtime needed
      allocate(local_mesh_ids(1))
      local_mesh_ids(1) = local_mesh%get_id()
    end if

  end subroutine gungho_transport_control_alg_init

  !=============================================================================
  !> @brief Advection of prognostic variables for the dynamical core.
  !> @param[in,out] advection_inc   Advection increment of the dynamics
  !!                                prognostics [u, rho, theta, exner]
  !> @param[in]     advected_fields Fields to advect: [u, rho, theta, exner]
  !> @param[in]     wind_np1        End of timestep wind field
  !> @param[in]     wind_n          Start of timestep wind field
  !> @param[in,out] mr_out          Moisture fields after transport
  !> @param[in]     mr_in           Moisture fields before transport
  !> @param[in]     model_clock     Time within the model
  !> @param[in]     outer           Outer (advection) iteration number
  !> @param[in]     cheap_update    Logical flag for cheap transport update
  !> @param[in]     prev_inc        (Optional) Advective increment after 1st outer
  !!                                iteration transport used for cheap transport update
  !> @param[in]     wind_prev       (Optional) Estimate of end of timestep wind from
  !!                                previous outer iteration
  !> @param[in]     rho_d_n         (Optional) dry density to be transported,
  !!                                without the predictor factor
  !> @param[in]     total_dry_flux  (Optional) the mass flux used to transport
  !!                                the dry density
  !> @param[in,out] adv_tracer_all_outer
  !!                                (Optional) Tracers after transport on every iteration
  !> @param[in]     adv_tracer_all_outer_after_slow
  !!                                (Optional) Tracers to transport every iteration
  !> @param[in,out] adv_tracer_last_outer
  !!                                (Optional) Tracers after transport on final iteration only
  !> @param[in]     adv_tracer_last_outer_after_slow
  !!                                (Optional) Tracers to transport on final iteration only
  !> @param[in,out] con_tracer_all_outer
  !!                                (Optional) Second group of tracers after transport on every iteration
  !> @param[in]     con_tracer_all_outer_after_slow
  !!                                (Optional) Second group of tracers to transport every iteration
  !> @param[in,out] con_tracer_last_outer
  !!                                (Optional) Second group of tracers after transport on final iteration only
  !> @param[in]     con_tracer_last_outer_after_slow
  !!                                (Optional) Second group of tracers to transport on final iteration only

  subroutine gungho_transport_control_alg(advection_inc, advected_fields,      &
                                          wind_np1, wind_n, mr_out, mr_in,     &
                                          model_clock, outer,                  &
                                          cheap_update, prev_inc, wind_prev,   &
                                          rho_d_n,                             &
                                          total_dry_flux,                      &
                                          adv_tracer_all_outer,                &
                                          adv_tracer_all_outer_after_slow,     &
                                          adv_tracer_last_outer,               &
                                          adv_tracer_last_outer_after_slow,    &
                                          con_tracer_all_outer,                &
                                          con_tracer_all_outer_after_slow,     &
                                          con_tracer_last_outer,               &
                                          con_tracer_last_outer_after_slow     &
                                          )

    use derived_config_mod,              only: bundle_size
    use sci_field_bundle_builtins_mod,   only: bundle_inc_axpby,               &
                                               clone_bundle,                   &
                                               set_bundle_scalar
    use field_collection_mod,            only: field_collection_type
    use field_indices_mod,               only: igh_u, igh_t, igh_d, igh_p
    use fs_continuity_mod,               only: Wtheta, W2, W3
    use function_space_collection_mod,   only: function_space_collection
    use function_space_mod,              only: function_space_type
    use intermesh_mappings_alg_mod,      only: map_w2_intermesh,               &
                                               map_rho_intermesh
    use io_config_mod,                   only: write_conservation_diag
    use model_clock_mod,                 only: model_clock_type
    use moisture_conservation_alg_mod,   only: moisture_conservation_alg
    use moist_mr_transport_alg_mod,      only: moist_mr_transport_alg
    use mr_indices_mod,                  only: nummr, nummr_to_transport
    use theta_transport_alg_mod,         only: theta_transport_alg
    use timestepping_config_mod,         only: outer_iterations
    use tracer_collection_transport_mod, only: tracer_collection_transport_alg, &
                                               coarse_collection_transport_alg
    use transport_field_mod,             only: transport_field
    use wind_transport_alg_mod,          only: wind_transport_alg

    implicit none

    ! Arguments
    type(field_type),            intent(inout) :: advection_inc(bundle_size)
    type(field_type),            intent(in)    :: advected_fields(bundle_size)
    type(field_type),            intent(in)    :: wind_np1
    type(field_type),            intent(in)    :: wind_n
    type(field_type),            intent(inout) :: mr_out(nummr)
    type(field_type),            intent(in)    :: mr_in(nummr)
    class(model_clock_type),     intent(in)    :: model_clock
    integer(kind=i_def),         intent(in)    :: outer
    logical(kind=l_def),         intent(in)    :: cheap_update
    type(field_type),            intent(in),    optional :: prev_inc(bundle_size)
    type(field_type),            intent(in),    optional :: wind_prev
    type(field_type),    target, intent(in),    optional :: rho_d_n
    type(r_tran_field_type),     intent(in),    optional :: total_dry_flux
    type(field_collection_type), intent(inout), optional :: adv_tracer_all_outer
    type(field_collection_type), intent(in),    optional :: adv_tracer_all_outer_after_slow
    type(field_collection_type), intent(inout), optional :: adv_tracer_last_outer
    type(field_collection_type), intent(in),    optional :: adv_tracer_last_outer_after_slow
    type(field_collection_type), intent(inout), optional :: con_tracer_all_outer
    type(field_collection_type), intent(in),    optional :: con_tracer_all_outer_after_slow
    type(field_collection_type), intent(inout), optional :: con_tracer_last_outer
    type(field_collection_type), intent(in),    optional :: con_tracer_last_outer_after_slow

    ! Internal variables
    logical(kind=l_def)                    :: do_moisture_diagnostics
    logical(kind=l_def)                    :: cheap_update_step

    ! Temporary fields or pointers
    type(field_type)                       :: fields_np1(bundle_size)
    type(field_type)                       :: wind_for_adv
    type(field_type)                       :: rho_d_np1
    type(field_type)                       :: aerosol_wind_n, aerosol_wind_np1
    type(field_type)                       :: aerosol_reference_rho
    type(field_type),              pointer :: rho_d_n_ptr
    type(field_type),              target  :: rho_d_n_trgt
    type(field_type),              pointer :: rho_d_latest_ptr
    type(field_type),              target  :: rho_d_latest_trgt
    type(r_tran_field_type),       pointer :: flux_this_outer

    type(mesh_type),               pointer :: aerosol_mesh
    type(function_space_type),     pointer :: aerosol_w2_fs
    type(function_space_type),     pointer :: aerosol_w3_fs

    ! Transport objects
    type(flux_precomputations_type), pointer :: flux_precomputations
    type(transport_metadata_type),   pointer :: transport_metadata
    type(transport_controller_type)          :: transport_controller
    type(transport_controller_type)          :: aerosol_transport_controller
    integer(tik)                             :: id_cont

    if ( LPROF ) call start_timing( id_cont, 'dynamics.transport' )
    ! ======================================================================== !
    ! Pre-transport initialisation tasks
    ! ======================================================================== !

    call clone_bundle(advected_fields, fields_np1, bundle_size)
    call set_bundle_scalar(0.0_r_def, fields_np1, bundle_size)

    ! Set rho to be used for transport of tracers ------------------------------
    if (present(rho_d_n)) then
      rho_d_n_ptr => rho_d_n
    else
      call advected_fields(igh_d)%copy_field_properties(rho_d_n_trgt)
      call invoke( setval_X(rho_d_n_trgt, advected_fields(igh_d)) )
      rho_d_n_ptr => rho_d_n_trgt
    end if

    ! Are we going to write out moisture conservation diagnostics? -------------
    do_moisture_diagnostics = (                                                &
        write_conservation_diag .and. outer == outer_iterations                &
        .and. present(rho_d_n)                                                 &
    )

    ! Determine aspects relating to cheap update steps -------------------------
    ! Check whether it is a cheap update step
    cheap_update_step = (cheap_update .and. outer > 1)

    call wind_for_adv%initialise( wind_n%get_function_space() )
    if (cheap_update .AND. outer > 2 .AND. present(wind_prev) ) then
      ! Use previous wind in the advecting wind calculation
      call invoke( setval_X(wind_for_adv, wind_prev) )
    else
      ! Use wind_n in the advecting wind calculation
      call invoke( setval_X(wind_for_adv, wind_n) )
    end if

    ! Reference density for all-outer groups needs updating
    if (cheap_update .AND. outer > 1 .AND. present(prev_inc)) then
      call rho_d_n_ptr%copy_field_properties(rho_d_latest_trgt)
      call invoke( X_plus_Y(rho_d_latest_trgt, rho_d_n_ptr, prev_inc(igh_d)) )
      rho_d_latest_ptr => rho_d_latest_trgt
    else
      rho_d_latest_ptr => rho_d_n_ptr
    end if

    ! Initialise the main transport controller ---------------------------------
    call transport_controller%initialise(                                      &
            model_clock, rho_d_latest_ptr, wind_for_adv, wind_np1, outer,      &
            cheap_update_step                                                  &
    )

    ! ======================================================================== !
    ! TRANSPORT OF PROGNOSTICS: EVERY OUTER LOOP
    ! ======================================================================== !

    ! ------------------------------------------------------------------------ !
    ! Transport dry density
    call log_event( "Transporting density...", LOG_LEVEL_DEBUG)
    transport_metadata =>                                                      &
        transport_metadata_collection%get_transport_metadata('density')

    call transport_field(                                                      &
            fields_np1(igh_d), advected_fields(igh_d),                         &
            transport_controller, transport_metadata                           &
    )
    call invoke( X_minus_Y( advection_inc(igh_d), fields_np1(igh_d),           &
                            advected_fields(igh_d) ) )

    ! Increment the whole time step's dry flux, which is to be used in the
    ! transport of tracers in the final outer step, if using the cheap update
    if (cheap_update) then
      flux_precomputations => transport_controller%get_flux_precomputations()
      flux_this_outer => flux_precomputations%get_total_ref_flux()
      call invoke( inc_X_plus_Y(total_dry_flux, flux_this_outer) )
    end if

    ! Check negative reference fields at this point
    if (check_any_eqn_consistent()) then
      call transport_controller%check_reference_field()
    end if

    ! ------------------------------------------------------------------------ !
    ! Transport wind field
    call log_event( "Transporting wind...", LOG_LEVEL_DEBUG)
    transport_metadata =>                                                      &
        transport_metadata_collection%get_transport_metadata('wind')

    call wind_transport_alg(                                                   &
            advection_inc(igh_u), advected_fields(igh_u),                      &
            transport_controller, transport_metadata                           &
    )
    ! We don't change advection_inc(igh_u) as wind_transport_alg
    ! already returns weak increment

    ! ------------------------------------------------------------------------ !
    ! Don't transport Exner pressure
    call invoke( setval_c(advection_inc(igh_p), 0.0_r_def) )

    ! ------------------------------------------------------------------------ !
    ! Transport moisture mixing ratio fields
    if ( moisture_formulation /= moisture_formulation_dry ) then
      ! Write out moisture diagnostics
      if ( do_moisture_diagnostics ) then
        call moisture_conservation_alg( rho_d_n, mr_in, 'Before transport' )
      end if

      call log_event(                                                          &
              "Transporting moisture mixing ratio fields...", LOG_LEVEL_DEBUG  &
      )
      transport_metadata =>                                                    &
          transport_metadata_collection%get_transport_metadata('moisture')

      call moist_mr_transport_alg(                                             &
              mr_out, mr_in, nummr_to_transport,                               &
              transport_controller, transport_metadata                         &
      )
      ! ---------------------------------------------------------------------- !
      ! Transport tracers which are active in fast physics, and therefore need
      ! transporting on every outer iteration
      if (present(adv_tracer_all_outer)                                        &
          .and. check_transport_name('adv_tracer') ) then
        call log_event(                                                        &
                 "Transporting advective tracers (all)...", LOG_LEVEL_DEBUG    &
        )
        transport_metadata =>                                                  &
            transport_metadata_collection%get_transport_metadata('adv_tracer')

        call tracer_collection_transport_alg(                                  &
                adv_tracer_all_outer, adv_tracer_all_outer_after_slow,         &
                transport_controller, transport_metadata                       &
        )
      end if
      if (present(con_tracer_all_outer)                                        &
          .and. check_transport_name('con_tracer') ) then
        call log_event(                                                        &
                "Transporting conservative tracers (all)...", LOG_LEVEL_DEBUG  &
        )
        transport_metadata =>                                                  &
            transport_metadata_collection%get_transport_metadata('con_tracer')

        call tracer_collection_transport_alg(                                  &
                con_tracer_all_outer, con_tracer_all_outer_after_slow,         &
                transport_controller, transport_metadata                       &
        )
      end if
    end if

    ! ------------------------------------------------------------------------ !
    ! Transport potential temperature
    ! (must be after moisture but before last_outer tracers due to cheap update)
    ! Note: the theta increment is pointwise
    call log_event( "Transporting potential temperature...", LOG_LEVEL_DEBUG)
    transport_metadata =>                                                      &
        transport_metadata_collection%get_transport_metadata('potential_temperature')

    call theta_transport_alg(                                                  &
            fields_np1(igh_t), advection_inc(igh_t), advected_fields(igh_t),   &
            mr_out, mr_in, transport_controller, transport_metadata            &
    )

    ! ======================================================================== !
    ! TRANSPORT OF PROGNOSTICS: LAST OUTER LOOP
    ! ======================================================================== !
    ! Transport fields which aren't needed in fast physics, and therefore
    ! only need transporting on the final outer iteration

    if ( outer == outer_iterations                                             &
         .and. moisture_formulation /= moisture_formulation_dry ) then

      ! ---------------------------------------------------------------------- !
      ! Reset transport controller, if required
      ! ---------------------------------------------------------------------- !
      if (cheap_update) then
        ! Transport is now with transporting wind for the whole time step, not
        ! the difference in winds from the cheap update
        call transport_controller%finalise()
        call transport_controller%initialise(                                  &
                model_clock, rho_d_n_ptr, wind_n, wind_np1,                    &
                outer=outer, cheap_update_step=.false.                         &
        )
        ! Copy dry density flux for the whole timestep into flux precomputations
        call transport_controller%initialise_flux_precomputations(total_dry_flux)

      end if
      if (use_multires_coupling .and. coarse_aerosol_transport) then
        ! First, need winds, fluxes and density on the coarser mesh
        aerosol_mesh => mesh_collection%get_mesh(aerosol_mesh_name)
        aerosol_w2_fs => function_space_collection%get_fs(aerosol_mesh, 0, 0, W2)
        aerosol_w3_fs => function_space_collection%get_fs(aerosol_mesh, 0, 0, W3)
        call aerosol_wind_n%initialise( aerosol_w2_fs )
        call aerosol_wind_np1%initialise( aerosol_w2_fs )
        call aerosol_reference_rho%initialise( aerosol_w3_fs )

        ! Restrict quantities to the coarse mesh
        call map_w2_intermesh(aerosol_wind_n, wind_n)
        call map_w2_intermesh(aerosol_wind_np1, wind_np1)
        call map_rho_intermesh(aerosol_reference_rho, rho_d_n_ptr)

        ! Set up new transport controller for coarser mesh
        call aerosol_transport_controller%initialise(                          &
                model_clock, aerosol_reference_rho, aerosol_wind_n,            &
                aerosol_wind_np1, outer, cheap_update_step=.false.             &
        )
        ! Copy dry density flux for the whole timestep into flux precomputations
        ! It does not need restricting (that will happen in the object)
        call aerosol_transport_controller%initialise_flux_precomputations(total_dry_flux)
      end if

      ! ---------------------------------------------------------------------- !
      ! Advective tracers
      if (present(adv_tracer_last_outer)                                       &
          .and. check_transport_name('adv_tracer') ) then
        call log_event(                                                        &
                "Transporting advective tracers (last)...", LOG_LEVEL_DEBUG    &
        )

        ! Get the transport metadata for last outer advective tracers
        transport_metadata =>                                                  &
            transport_metadata_collection%get_transport_metadata('adv_tracer')

        call tracer_collection_transport_alg(                                  &
                adv_tracer_last_outer, adv_tracer_last_outer_after_slow,       &
                transport_controller, transport_metadata                       &
        )
      end if

      ! ---------------------------------------------------------------------- !
      ! Conservative tracers
      if (present(con_tracer_last_outer)                                       &
          .and. check_transport_name('con_tracer') ) then
        call log_event(                                                        &
                "Transporting conservative tracers (last)...", LOG_LEVEL_DEBUG &
        )

        ! Get the transport metadata for last outer conservative tracers
        transport_metadata =>                                                  &
            transport_metadata_collection%get_transport_metadata('con_tracer')

        if (use_multires_coupling .and. coarse_aerosol_transport) then
          call coarse_collection_transport_alg(                                &
                  con_tracer_last_outer, con_tracer_last_outer_after_slow,     &
                  aerosol_transport_controller, transport_metadata             &
          )
        else
          call tracer_collection_transport_alg(                                &
                  con_tracer_last_outer, con_tracer_last_outer_after_slow,     &
                  transport_controller, transport_metadata                     &
          )
        end if
      end if
    end if

    ! ------------------------------------------------------------------------ !
    ! Write out moisture diagnostics
    if (do_moisture_diagnostics) then
      call rho_d_n%copy_field_properties(rho_d_np1)
      call invoke( X_plus_Y(rho_d_np1, rho_d_n, advection_inc(igh_d)) )
      call moisture_conservation_alg( rho_d_np1, mr_out, 'After transport' )
    end if

    ! ---------------------------------------------------------------------- !
    ! If cheap update we need to add the previous iteration state increments
    if (cheap_update .AND. outer > 1) then
      ! Add the previous iteration state increments for density, theta and u
      ! On the second outer iteration we have
      ! advection_inc = dt increment(field,(wind_np1-wind_n)/2)
      ! prev_inc      = dt increment(field,(wind_n)/2)
      ! We set
      ! advection_inc = advection_inc + prev_inc = dt increment(field,(wind_np1+wind_n)/2)
      ! This carries forward for further outer iterations
      call invoke( inc_X_plus_Y(advection_inc(igh_d), prev_inc(igh_d)),        &
                   inc_X_plus_Y(advection_inc(igh_t), prev_inc(igh_t)),        &
                   inc_X_plus_Y(advection_inc(igh_u), prev_inc(igh_u)) )
      ! For moisture and tracers the cheap update is done automatically as the output is the
      ! field after transport (compared to the transport increment for the state fields).
      ! From the first outer iteration we have
      ! mr_1 = mr_n - dt increment(mr,wind_n)
      ! On the second outer iteration we have
      ! mr_out = mr_1 - dt increment(mr_1,(wind_np1-wind_n)/2)
      ! This carries forward for further outer iterations
    end if

    ! Finalise transport controller objects
    call transport_controller%finalise()
    call aerosol_transport_controller%finalise()

    if ( LPROF ) call stop_timing( id_cont, 'dynamics.transport' )

  end subroutine gungho_transport_control_alg

  !=============================================================================
  !> @brief Calls finalising routines for gungho transport.
  subroutine gungho_transport_control_alg_final()

    use split_transport_utils_mod,        only: finalise_split_transport_utils

    implicit none

    call finalise_split_transport_utils()

  end subroutine gungho_transport_control_alg_final

end module gungho_transport_control_alg_mod
