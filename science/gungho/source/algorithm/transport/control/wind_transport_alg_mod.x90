!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains routine for transporting the wind field.

module wind_transport_alg_mod

  use constants_mod,                  only: i_def, r_def, l_def
  use sci_dg_convert_hdiv_field_kernel_mod,                                    &
                                      only: dg_convert_hdiv_field_kernel_type
  use sci_dg_convert_hdiv_native_kernel_mod,                                   &
                                      only: dg_convert_hdiv_native_kernel_type
  use sci_enforce_bc_kernel_mod,      only: enforce_bc_kernel_type
  use sci_fem_constants_mod,          only: get_mass_matrix_fe,         &
                                            get_mass_matrix_fv,         &
                                            get_rmultiplicity_fe,       &
                                            get_rmultiplicity_fv,       &
                                            get_inverse_mass_matrix_fe, &
                                            get_inverse_mass_matrix_fv
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: coord_system, coord_system_native
  use formulation_config_mod,         only: si_momentum_equation
  use fs_continuity_mod,              only: W2, W3, W2broken
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use sci_geometric_constants_mod,    only: get_coordinates, get_panel_id
  use log_mod,                        only: log_event,       &
                                            LOG_LEVEL_ERROR, &
                                            LOG_LEVEL_TRACE
  use sci_mapping_constants_mod,      only: get_project_xdot_to_w2,  &
                                            get_project_ydot_to_w2,  &
                                            get_project_zdot_to_w2
  use mesh_mod,                       only: mesh_type
  use operator_mod,                   only: operator_type
  use timing_mod,                     only: start_timing, stop_timing, &
                                            tik, LPROF
  use transport_config_mod,           only: broken_w2_projection
  use transport_constants_mod,        only: get_element_order_h_transport, &
                                            get_element_order_v_transport
  use transport_controller_mod,       only: transport_controller_type
  use transport_enumerated_types_mod, only: equation_form_advective
  use transport_field_mod,            only: transport_field
  use transport_metadata_mod,         only: transport_metadata_type

  implicit none

  private

  public :: wind_transport_alg

contains

  !=============================================================================
  !> @brief Central routine for transporting the wind field.
  !> @details Performs a whole transport time step for the wind field, with
  !!          different routines called depending on the form of the transport
  !!          equation being used.
  !> @param[in,out] rhs_u              Right-hand-side for weak wind transport
  !!                                   equation. In other words, the advective
  !!                                   increment to the wind multiplied by the
  !!                                   W2 mass matrix.
  !> @param[in]     wind_n             Wind field at start of transport step
  !> @param[in,out] transport_controller
  !!                                   Encapsulating object containing the
  !!                                   transport counter and precomputations
  !> @param[in,out] transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine wind_transport_alg(rhs_u, wind_n, transport_controller,           &
                                transport_metadata)

    use dg_matrix_vector_kernel_mod,      only: dg_matrix_vector_kernel_type
    use dg_inc_matrix_vector_kernel_mod,  only: dg_inc_matrix_vector_kernel_type
    use matrix_vector_kernel_mod,         only: matrix_vector_kernel_type
    use sci_average_w2b_to_w2_kernel_mod, only: average_w2b_to_w2_kernel_type
    use sci_field_minmax_alg_mod,         only: log_field_minmax

    implicit none

    ! Arguments
    type(field_type),                intent(inout) :: rhs_u
    type(field_type),                intent(in)    :: wind_n
    type(transport_controller_type), intent(inout) :: transport_controller
    type(transport_metadata_type),   intent(inout) :: transport_metadata

    ! Internal variables
    type(mesh_type),           pointer  :: mesh
    integer(kind=i_def)                 :: dir
    integer(kind=i_def)                 :: k_h, k_v
    type(field_type)                    :: u_w3_n(3), u_w3_inc(3), u_w3_np1(3)
    type(field_type)                    :: u_w2_inc, u_w2b_inc, rhs_u_broken
    type(field_type),           pointer :: chi(:)
    type(field_type),           pointer :: panel_id
    type(field_type),           pointer :: rmultiplicity_w2
    type(operator_type),        pointer :: mm_w2
    type(operator_type),        pointer :: mm_w2b_inv
    type(operator_type),        pointer :: project_xdot_to_w2
    type(operator_type),        pointer :: project_ydot_to_w2
    type(operator_type),        pointer :: project_zdot_to_w2
    type(function_space_type),  pointer :: w3_fs
    type(function_space_type),  pointer :: w2_fs
    type(function_space_type),  pointer :: w2b_fs
    logical(kind=l_def)                 :: optimised_conversion
    integer(tik)                        :: id_to, id_from

    k_h = get_element_order_h_transport()
    k_v = get_element_order_v_transport()

    ! ------------------------------------------------------------------------ !
    ! Semi-implicit formulation
    ! ------------------------------------------------------------------------ !
    if ( si_momentum_equation ) then
      ! Transport terms are handled by the semi-implicit scheme
      ! so the increment is zero
      call invoke( setval_c(rhs_u, 0.0_r_def) )

    else
      ! Transport the wind. First choose form of transport equation
      select case ( transport_metadata%get_equation_form() )

      ! ---------------------------------------------------------------------- !
      ! Advective form of transport equation
      ! ---------------------------------------------------------------------- !
      case ( equation_form_advective )

        ! Compute u in physical space and advect components in geocentric
        ! Cartesian coordinates and then map back to computational form

        mesh => wind_n%get_mesh()
        w3_fs => function_space_collection%get_fs( mesh, k_h, k_v, W3 )
        chi => get_coordinates(mesh%get_id())
        panel_id => get_panel_id(mesh%get_id())

        ! -------------------------------------------------------------------- !
        ! Split wind into components in W3
        ! -------------------------------------------------------------------- !

        if ( LPROF ) call start_timing( id_to, 'transport.wind_to_comps' )

        do dir = 1,3
          call u_w3_n(dir)%initialise( w3_fs )
          call u_w3_inc(dir)%initialise( w3_fs )
          call u_w3_np1(dir)%initialise( w3_fs )
        end do
        call log_field_minmax( LOG_LEVEL_TRACE, 'advected u', wind_n )

        optimised_conversion = (                                               &
          coord_system == coord_system_native                                  &
          .and. w3_fs%get_element_order_h() == 0                               &
          .and. w3_fs%get_element_order_v() == 0                               &
        )
        if (optimised_conversion) then
          call invoke( dg_convert_hdiv_native_kernel_type(                     &
                  u_w3_n, wind_n, chi, panel_id                                &
          ) )
        else
          call invoke( dg_convert_hdiv_field_kernel_type(                      &
                  u_w3_n, wind_n, chi, panel_id                                &
          ) )
        end if

        call log_field_minmax( LOG_LEVEL_TRACE, 'xdot', u_w3_n(1) )
        call log_field_minmax( LOG_LEVEL_TRACE, 'ydot', u_w3_n(2) )
        call log_field_minmax( LOG_LEVEL_TRACE, 'zdot', u_w3_n(3) )

        if ( LPROF ) call stop_timing( id_to, 'transport.wind_to_comps' )

        ! -------------------------------------------------------------------- !
        ! Transport wind components in W3
        ! -------------------------------------------------------------------- !

        do dir = 1,3
          call transport_field(                                                &
                  u_w3_np1(dir), u_w3_n(dir), transport_controller,            &
                  transport_metadata                                           &
          )
        end do

        ! -------------------------------------------------------------------- !
        ! Return from components to full wind field in W2
        ! -------------------------------------------------------------------- !

        if ( LPROF ) call start_timing( id_from, 'transport.wind_from_comps' )

        project_xdot_to_w2 => get_project_xdot_to_w2(mesh%get_id())
        project_ydot_to_w2 => get_project_ydot_to_w2(mesh%get_id())
        project_zdot_to_w2 => get_project_zdot_to_w2(mesh%get_id())

        ! Either Galerkin project in W2broken
        if (broken_w2_projection) then
          ! Galerkin projection into W2broken, then restore continuity
          w2_fs => function_space_collection%get_fs( mesh, k_h, k_v, W2 )
          w2b_fs => function_space_collection%get_fs( mesh, k_h, k_v, W2broken )
          if (k_h == 0 .and. k_v == 0) then
            mm_w2 => get_mass_matrix_fv(W2, mesh%get_id())
            mm_w2b_inv => get_inverse_mass_matrix_fv(W2broken, mesh%get_id())
            rmultiplicity_w2 => get_rmultiplicity_fv(W2, mesh%get_id())
          else
            mm_w2 => get_mass_matrix_fe(W2, mesh%get_id())
            mm_w2b_inv => get_inverse_mass_matrix_fe(W2broken, mesh%get_id())
            rmultiplicity_w2 => get_rmultiplicity_fe(W2, mesh%get_id())
          end if

          call rhs_u_broken%initialise( w2b_fs )
          call u_w2b_inc%initialise( w2b_fs )
          call u_w2_inc%initialise( w2_fs )

          call invoke( name="perform_broken_projection_for_wind_inc",          &
                       X_minus_Y( u_w3_inc(1), u_w3_np1(1), u_w3_n(1) ),       &
                       X_minus_Y( u_w3_inc(2), u_w3_np1(2), u_w3_n(2) ),       &
                       X_minus_Y( u_w3_inc(3), u_w3_np1(3), u_w3_n(3) ),       &
                       setval_c(rhs_u_broken, 0.0_r_def),                      &
                       setval_c(rhs_u, 0.0_r_def),                             &
                       setval_c(u_w2_inc, 0.0_r_def),                          &
                       dg_inc_matrix_vector_kernel_type(rhs_u_broken,          &
                                                        u_w3_inc(1),           &
                                                        project_xdot_to_w2),   &
                       dg_inc_matrix_vector_kernel_type(rhs_u_broken,          &
                                                        u_w3_inc(2),           &
                                                        project_ydot_to_w2),   &
                       dg_inc_matrix_vector_kernel_type(rhs_u_broken,          &
                                                        u_w3_inc(3),           &
                                                        project_zdot_to_w2),   &
                       dg_matrix_vector_kernel_type(u_w2b_inc, rhs_u_broken,   &
                                                    mm_w2b_inv),               &
                       average_w2b_to_w2_kernel_type(u_w2_inc, u_w2b_inc,      &
                                                     rmultiplicity_w2),        &
                       matrix_vector_kernel_type(rhs_u, u_w2_inc, mm_w2),      &
                       enforce_bc_kernel_type(rhs_u) )

        else
          ! Assemble right-hand side for Galerkin projection into W2
          call invoke( name="perform_galerkin_projection_for_wind_inc",        &
                       X_minus_Y( u_w3_inc(1), u_w3_np1(1), u_w3_n(1) ),       &
                       X_minus_Y( u_w3_inc(2), u_w3_np1(2), u_w3_n(2) ),       &
                       X_minus_Y( u_w3_inc(3), u_w3_np1(3), u_w3_n(3) ),       &
                       setval_c(rhs_u, 0.0_r_def),                             &
                       matrix_vector_kernel_type(rhs_u, u_w3_inc(1),           &
                                                 project_xdot_to_w2),          &
                       matrix_vector_kernel_type(rhs_u, u_w3_inc(2),           &
                                                 project_ydot_to_w2),          &
                       matrix_vector_kernel_type(rhs_u, u_w3_inc(3),           &
                                                 project_zdot_to_w2),          &
                       enforce_bc_kernel_type(rhs_u) )
        end if

        if ( LPROF ) call stop_timing( id_from, 'transport.wind_from_comps' )

      ! ---------------------------------------------------------------------- !
      ! Default form of transport equation
      ! ---------------------------------------------------------------------- !
      case default
        call log_event(                                                        &
                'Form of wind transport equation either not compatible ' //    &
                'with wind transport or not implemented',                      &
                LOG_LEVEL_ERROR                                                &
        )

      end select

    end if ! si_momentum_equation

  end subroutine wind_transport_alg

end module wind_transport_alg_mod
