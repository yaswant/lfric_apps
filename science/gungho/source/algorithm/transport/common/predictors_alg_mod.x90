!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief   Algorithm to set density and wind predictors for transport in GungHo.
!> @details The semi-implicit time stepping method requires the Eulerian transported
!!          wind and density to be modified by a predictor to ensure stability.
!!          The predictors help mimic the semi-implicit semi-Lagrangian discretisation,
!!          and have the form:
!!         \f[ \mathbf{u}_P = RHS_\mathbf{u} \f]
!!         \f[ \rho_P = \rho \times (1 - \beta \Delta{t} \nabla \cdot \mathbf{u}) \f]

module predictors_alg_mod

  ! Constants and types
  use constants_mod,              only: r_def
  use sci_fem_constants_mod,      only: get_im3_div_fe, &
                                        get_im3_div_fv
  use field_indices_mod,          only: igh_u, igh_d
  use field_mod,                  only: field_type
  use model_clock_mod,            only: model_clock_type
  use operator_mod,               only: operator_type
  use timing_mod,                 only: start_timing, stop_timing, &
                                        tik, LPROF

  ! Configurations
  use derived_config_mod,         only: bundle_size
  use formulation_config_mod,     only: horizontal_transport_predictor, &
                                        si_momentum_equation
  use transport_config_mod,       only: use_density_predictor, &
                                        cap_density_predictor

  ! Algorithms and Kernels
  use dg_matrix_vector_kernel_mod, &
                                  only: dg_matrix_vector_kernel_type
  use sci_mass_matrix_solver_alg_mod, &
                                  only: mass_matrix_solver_alg
  use sci_hori_mass_matrix_solver_alg_mod, &
                                  only: hori_mass_matrix_solver_alg

  implicit none

  private
  public :: predictors_alg

contains

  !===========================================================================!
  !> @brief Applies predictors to wind and density.
  !> @details The wind and density fields need predictors to work with
  !!          the semi-implicit time stepping scheme. The divergence factor,
  !!          used in the density predictor, can be capped to lie between
  !!          two given values.
  !!
  !> @param[in,out] advected_state The state variables that will be transported
  !> @param[in]     wind           The wind at time n
  !> @param[in]     rhs_n          The RHS terms for u at time n
  !> @param[in]     beta           The time n centring parameter
  !> @param[in]     model_clock    Time within the model
  subroutine predictors_alg( advected_state, &
                             wind,           &
                             rhs_n,          &
                             beta,           &
                             model_clock )

    implicit none

    ! Arguments
    type( field_type ),        intent(inout) :: advected_state(bundle_size)
    type( field_type ),        intent(in)    :: wind
    type( field_type ),        intent(in)    :: rhs_n
    real( kind=r_def ),        intent(in)    :: beta
    class( model_clock_type ), intent(in)    :: model_clock

    ! Fields and values needed for the density predictor
    type(field_type) :: divergence
    type(field_type) :: div_factor
    real(kind=r_def) :: beta_dt
    real(kind=r_def) :: df_min
    real(kind=r_def) :: df_max
    real(kind=r_def) :: cast_dt
    ! Timing identifier
    integer(tik)     :: id

    ! Divergence operator
    type(operator_type), pointer :: im3_div => null()

    if ( LPROF ) call start_timing( id, "dynamics.transport_predictors")

    ! Predictor of the wind field (u-beta*dt*rhs)
    if ( .not. si_momentum_equation ) then
      if (horizontal_transport_predictor) then
        call hori_mass_matrix_solver_alg(advected_state(igh_u), rhs_n, advected_state(igh_u))
      else
        call mass_matrix_solver_alg(advected_state(igh_u), rhs_n)
      end if
    end if

    ! Density predictor
    if ( use_density_predictor ) then
      ! Predictor of density - the density increment becomes:
      ! d(rho)/dt + div(div_factor*rho u) = 0
      ! div_factor = 1 - beta*dt*m3_inv*div*wind_n

      ! Get time step for density predictor
      cast_dt = real(model_clock%get_seconds_per_step(), r_def)

      ! Get div operator and beta*dt
      if (advected_state(igh_d)%get_element_order_h() > 0 .or. &
          advected_state(igh_d)%get_element_order_v() > 0) then
        im3_div  => get_im3_div_fe(advected_state(igh_d)%get_mesh_id())
      else
        im3_div  => get_im3_div_fe(advected_state(igh_d)%get_mesh_id())
      end if
      beta_dt = beta*cast_dt

      ! Initialise fields used in divergence factor computation
      call divergence%initialise( advected_state(igh_d)%get_function_space() )
      call div_factor%initialise( advected_state(igh_d)%get_function_space() )

      ! Set min/max values divergence factor can take
      df_min = 1.0_r_def-cap_density_predictor
      df_max = 1.0_r_def+cap_density_predictor

      ! Compute divergence factor and apply predictor to density
      call invoke( name = "compute_density_predictor",              &
                   dg_matrix_vector_kernel_type(divergence,         &
                                                wind,               &
                                                im3_div),           &
                   setval_c(div_factor, 1.0_r_def),                 &
                   inc_X_minus_bY(div_factor, beta_dt, divergence), &
                   ! Ensure div_factor lies in the range df_min < div_factor < df_max
                   inc_max_aX(df_min,div_factor),                   &
                   inc_min_aX(df_max,div_factor),                   &
                   inc_X_times_Y(advected_state(igh_d), div_factor) )

      nullify( im3_div )
    end if

    if ( LPROF ) call stop_timing( id, "dynamics.transport_predictors")

  end subroutine predictors_alg

end module predictors_alg_mod
