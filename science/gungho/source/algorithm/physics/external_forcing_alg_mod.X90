!-------------------------------------------------------------------------------
! (C) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------
!> @brief Interface to external forcing code.
module external_forcing_alg_mod

  use external_forcing_config_mod,     only: theta_forcing,                      &
                                             theta_forcing_none,                 &
                                             theta_forcing_held_suarez,          &
                                             theta_forcing_earth_like,           &
                                             theta_forcing_tidally_locked_earth, &
                                             theta_forcing_shallow_hot_jupiter,  &
                                             theta_forcing_deep_hot_jupiter,     &
                                             theta_forcing_temp_tend,            &
                                             theta_relaxation,                   &
                                             vapour_forcing,                     &
                                             vapour_forcing_none,                &
                                             vapour_forcing_profile,             &
                                             wind_forcing,                       &
                                             wind_forcing_none,                  &
                                             wind_forcing_held_suarez,           &
                                             wind_forcing_filtering,             &
                                             wind_forcing_diffusion,             &
                                             wind_forcing_profile,               &
                                             vertadvect_forcing,                 &
                                             geostrophic_forcing,                &
                                             filtering_order,                    &
                                             diffusion_order,                    &
                                             diffusion_coefficient,              &
                                             pc2_force_response
  use log_mod,                         only: log_event, log_scratch_space,       &
                                             LOG_LEVEL_INFO, LOG_LEVEL_ERROR
  use lfric_xios_write_mod,            only: write_field_generic
  use field_parent_mod,                only: write_interface

  use held_suarez_fv_kernel_mod,       only: held_suarez_fv_kernel_type
  use held_suarez_fv_wind_kernel_mod,  only: held_suarez_fv_wind_kernel_type
  use earth_like_kernel_mod,           only: earth_like_kernel_type
  use tidally_locked_earth_kernel_mod, only: tidally_locked_earth_kernel_type
  use shallow_hot_jupiter_kernel_mod,  only: shallow_hot_jupiter_kernel_type
  use deep_hot_jupiter_kernel_mod,     only: deep_hot_jupiter_kernel_type
  use momentum_smagorinsky_kernel_mod, only: momentum_smagorinsky_kernel_type
#ifdef UM_PHYSICS
  use pc2_force_response_alg_mod,      only: pc2_force_response_alg
#endif
  ! Derived Types
  use constants_mod,                   only: i_def, r_def, l_def
  use field_mod,                       only: field_type
  use field_collection_mod,            only: field_collection_type

  use fs_continuity_mod,               only: W1, W2, Wtheta
  use sci_fem_constants_mod,           only: get_rmultiplicity_fv
  use sci_geometric_constants_mod,     only: get_coordinates, &
                                             get_da_at_w2,    &
                                             get_panel_id,    &
                                             get_height_fv,   &
                                             get_dx_at_w2
  use mesh_mod,                        only: mesh_type
  use mr_indices_mod,                  only: nummr
  use io_config_mod,                   only: write_diag, use_xios_io
  use planet_config_mod,               only: kappa
  use section_choice_config_mod,       only: cloud, cloud_um
  use cloud_config_mod,                only: scheme, scheme_pc2

  use reference_element_mod,           only: T
  use sci_set_any_dof_kernel_mod,      only: set_any_dof_kernel_type

  use vertadvect_forcing_alg_mod,      only: vertadvect_forcing_alg
  use temp_tend_profile_alg_mod,       only: temp_tend_profile_alg
  use theta_relax_alg_mod,             only: theta_relax_alg
  use geostrophic_forcing_alg_mod,     only: geostrophic_forcing_alg
  use vapour_forcing_profile_alg_mod,  only: vapour_forcing_profile_alg
  use wind_forcing_profile_alg_mod,    only: wind_forcing_profile_alg

  use timing_mod,                      only: start_timing, stop_timing, &
                                             tik, LPROF

  use w2_filter_alg_mod,               only: w2_filter_alg

  use external_forcing_diagnostics_mod, only: write_forcing_diagnostics

  implicit none

  private
  public :: external_forcing_alg

contains

  !> @details Interface to external forcing of temperature and wind.
  !>          The choices of temperature and wind forcing are independent,
  !>          such that any combination of temperature forcing will work with
  !>          any combination of wind forcing (or either can be set to none
  !>          and unforced).
  !> @param[in]     derived_fields     Group of derived fields
  !> @param[in]     u                  3D wind field
  !> @param[in]     theta              Theta field
  !> @param[in]     exner              Exner pressure
  !> @param[in]     exner_in_wth       Exner pressure on Wtheta space
  !> @param[in]     rho                Dry air density
  !> @param[in]     mr_n               Mixing ratios at start of timestep
  !> @param[in]     cloud_fields       Group of cloud fields
  !> @param[in]     twod_mesh          2d mesh
  !> @param[in]     dt                 The model timestep length
  !> @param[in]     time_now           Current model time (seconds)
  !> @param[out]    dtheta_forcing     Theta increment from external forcing
  !> @param[out]    du_forcing         Wind increment from external forcing
  !> @param[out]    dmv_forcing        Vapour increment from external forcing
  !> @param[out]    dmcl_forcing       Liquid increment from external forcing
  !> @param[out]    dcfl_forcing       Cloud Liquid fraction increment
  !> @param[out]    dbcf_forcing       Cloud bulk fraction increment
  !> @param[in,out] theta_forcing_done Flag to say if theta code run
  !> @param[in,out] vapour_forcing_done Flag to say if vapour code run
  !> @param[in,out] wind_forcing_done  Flag to say if wind code run
  subroutine external_forcing_alg(derived_fields, u, theta, exner,             &
                                  exner_in_wth, rho, mr_n, cloud_fields,       &
                                  twod_mesh, dt, time_now, dtheta_forcing,     &
                                  du_forcing, dmv_forcing, dmcl_forcing,       &
                                  dcfl_forcing, dbcf_forcing,                  &
                                  theta_forcing_done, vapour_forcing_done,     &
                                  wind_forcing_done)

    implicit none

    type( field_collection_type ), intent( in ) :: derived_fields, cloud_fields
    type( field_type ), intent( in )            :: u, theta, exner, exner_in_wth, rho
    type( field_type ), intent( in )            :: mr_n(nummr)
    type( field_type ), intent( out )           :: dtheta_forcing, du_forcing
    type( field_type ), intent( out )           :: dmv_forcing, dmcl_forcing, &
                                                   dcfl_forcing, dbcf_forcing
    type( mesh_type ),  intent( in ), pointer   :: twod_mesh
    real( kind=r_def ), intent( in )            :: dt, time_now
    logical( kind=l_def ), intent(inout)        :: theta_forcing_done,  &
                                                   vapour_forcing_done, &
                                                   wind_forcing_done

    ! Temporary field to unpack from field collection
    type( field_type ), pointer :: u_physics => null()
    type( field_type ), pointer :: w2_rmultiplicity => null()
    type( field_type ), pointer :: dA => null()
    type( field_type ), pointer :: chi(:) => null()
    type( field_type ), pointer :: panel_id => null()
    type( field_type ), pointer :: height_wth => null()
    type( field_type ), pointer :: height_w1 => null()
    type( field_type ), pointer :: height_w2 => null()
    type( field_type ), pointer :: dx_at_w2 => null()

    type( field_type ) :: u_smoothed, dx, visc_m

    integer( kind=i_def ) :: order, nlayers
    real( kind=r_def )    :: diffusion_coefficient_scaled, dx_sum, dx_size

    type( mesh_type ),  pointer :: mesh => null()
    procedure(write_interface), pointer :: write_behaviour => null()
    integer(tik)                        :: id

    if ( LPROF ) call start_timing( id, 'external_forcing' )

    mesh => theta%get_mesh()
    height_wth => get_height_fv( Wtheta, mesh%get_id() )

    if ( theta_forcing /= theta_forcing_none .or. theta_relaxation .or.           &
         vertadvect_forcing ) then
      call dtheta_forcing%initialise( vector_space = theta%get_function_space() )
      call invoke( setval_c(dtheta_forcing, 0.0_r_def) )
    end if

    if (theta_forcing /= theta_forcing_none) then

      chi => get_coordinates( mesh%get_id() )
      panel_id => get_panel_id( mesh%get_id() )

      select case(theta_forcing)

        case(theta_forcing_held_suarez)

          call log_event( 'slow_physics: Running Held-Suarez theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(held_suarez_fv_kernel_type(dtheta_forcing, theta, &
                                                 exner_in_wth, chi,     &
                                                 panel_id, kappa, dt) )

        case(theta_forcing_earth_like)

          call log_event( 'slow_physics: Running Earth-Like theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(earth_like_kernel_type(dtheta_forcing, theta,         &
                                             exner_in_wth, height_wth, chi, &
                                             panel_id, kappa, dt) )

        case(theta_forcing_tidally_locked_earth)

          call log_event( 'slow_physics: Running TLE theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(tidally_locked_earth_kernel_type(dtheta_forcing, theta, &
                                                       exner_in_wth, chi,     &
                                                       panel_id, kappa, dt) )

        case(theta_forcing_shallow_hot_jupiter)

          call log_event( 'slow_physics: Running shallow hot Jupiter theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(shallow_hot_jupiter_kernel_type(dtheta_forcing, theta, &
                                                      exner_in_wth, height_wth, chi, &
                                                      panel_id, kappa, dt) )

        case(theta_forcing_deep_hot_jupiter)

          call log_event( 'slow_physics: Running deep hot Jupiter theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(deep_hot_jupiter_kernel_type(dtheta_forcing, theta, &
                                                   exner_in_wth, chi, panel_id, dt) )

        case(theta_forcing_temp_tend)

          call temp_tend_profile_alg( dtheta_forcing, exner_in_wth, time_now )

        case default

          call log_event( 'slow_physics: Incorrect theta_forcing option', &
                          LOG_LEVEL_ERROR )

      end select

      theta_forcing_done = .true. ! Collect this increment later on

      if (write_diag .and. use_xios_io) then
        write_behaviour => write_field_generic
        call dtheta_forcing%set_write_behaviour(write_behaviour)
        call dtheta_forcing%write_field('forcing__dtheta_force')
      end if

      nullify( chi, panel_id )

    end if

    if ( theta_relaxation ) then
      nlayers = mesh%get_nlayers()
      call theta_relax_alg( dtheta_forcing, theta, exner_in_wth, &
                            twod_mesh, time_now, nlayers )
      theta_forcing_done = .true.
    end if

    if (wind_forcing /= wind_forcing_none) then

      select case(wind_forcing)

        case(wind_forcing_held_suarez)

          call log_event( 'slow_physics: Running Held-Suarez wind forcing', &
                          LOG_LEVEL_INFO )

          w2_rmultiplicity => get_rmultiplicity_fv( W2, mesh%get_id() ) ! 1/multiplicity of w2
          dA => get_da_at_w2( mesh%get_id() )

          call derived_fields%get_field('u_physics', u_physics)

          call du_forcing%initialise( vector_space = u_physics%get_function_space() )
          call invoke(setval_c(du_forcing, 0.0_r_def))

          call invoke(held_suarez_fv_wind_kernel_type(du_forcing, u_physics, &
                                                      w2_rmultiplicity,      &
                                                      exner, exner_in_wth,   &
                                                      kappa, dt),            &
                      inc_X_times_Y(du_forcing, dA) )

          nullify( w2_rmultiplicity, u_physics, dA )

        case(wind_forcing_filtering)

          write(log_scratch_space,'(A,I3)')                                &
               'slow_physics: Running wind filtering forcing with order ', &
                filtering_order
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          call du_forcing%initialise( vector_space = u%get_function_space() )
          call invoke(setval_c(du_forcing, 0.0_r_def))

          call u_smoothed%initialise( vector_space = u%get_function_space() )
          call invoke(setval_X(u_smoothed, u))

          do order = 1, filtering_order
            call w2_filter_alg(u_smoothed)
          end do
          call invoke(X_minus_Y(du_forcing, u_smoothed, u))

        case(wind_forcing_diffusion)

          write(log_scratch_space,'(A,F6.3,A,I3)')                                  &
               'slow_physics: Running horizontal wind diffusion with coefficient ', &
               diffusion_coefficient, 'and order ', diffusion_order
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          ! The code below uses the Smagorinsky kernel to calculate the
          ! the horizontal diffusion of wind. Note the diffusion coefficient
          ! in this code is dimensionless which means we first scale it with
          ! the typical horizontal grid scale size.
          !
          ! Also note we turn off the horizontal diffusion of the vertical
          ! wind component by setting the returned vertical wind increment to
          ! zero.
          !
          panel_id => get_panel_id(mesh%get_id())
          height_w1 => get_height_fv(W1, mesh%get_id())
          height_w2 => get_height_fv(W2, mesh%get_id())

          dx_at_w2 => get_dx_at_w2(mesh%get_id())

          call visc_m%initialise( vector_space = theta%get_function_space())
          call dx%initialise( vector_space = dx_at_w2%get_function_space() )
          call invoke(setval_c(dx, 1.0_r_def))
          call invoke(sum_X(dx_sum, dx_at_w2))
          call invoke(sum_X(dx_size, dx))
          diffusion_coefficient_scaled = diffusion_coefficient * (dx_sum / dx_size) ** 2
          call invoke(setval_c(visc_m, diffusion_coefficient_scaled))

          call du_forcing%initialise( vector_space = u%get_function_space() )
          call invoke(setval_c(du_forcing, 0.0_r_def))

          call u_smoothed%initialise( vector_space = u%get_function_space() )
          call invoke(setval_X(u_smoothed, u))

          do order = 1, diffusion_order
            call invoke(momentum_smagorinsky_kernel_type(du_forcing, &
                                                         u_smoothed, &
                                                         1,          &
                                                         dx_at_w2,   &
                                                         1,          &
                                                         height_w2,  &
                                                         height_w1,  &
                                                         visc_m,     &
                                                         1,          &
                                                         panel_id,   &
                                                         1))
            call invoke(set_any_dof_kernel_type(du_forcing, T, 0.0_r_def))
            call invoke(inc_X_plus_Y(u_smoothed, du_forcing),        &
                        setval_c(du_forcing, 0.0_r_def))
          end do
          call invoke(X_minus_Y(du_forcing, u_smoothed, u))

          nullify(panel_id, height_w1, height_w2, dx_at_w2)

        case( wind_forcing_profile )

          call du_forcing%initialise( vector_space = u%get_function_space() )

          call wind_forcing_profile_alg( du_forcing, exner, time_now )

        case default

          call log_event( 'slow_physics: Incorrect wind_forcing option', &
                          LOG_LEVEL_ERROR )

      end select

      wind_forcing_done = .true. ! Collect this increment later on

      nullify( w2_rmultiplicity, u_physics, dA )

    end if

    if ( geostrophic_forcing ) then
      if ( .not. wind_forcing_done ) then
        call du_forcing%initialise( vector_space = u%get_function_space() )
        call invoke(setval_c(du_forcing, 0.0_r_def))
      end if

      call geostrophic_forcing_alg( du_forcing, derived_fields, exner, time_now )

      wind_forcing_done = .true.

    end if

    nullify( mesh )

    if ( vertadvect_forcing ) then
      if ( .not.vapour_forcing_done) then
        call dmv_forcing%initialise( vector_space = theta%get_function_space() )
        call invoke( setval_c(dmv_forcing, 0.0_r_def) )
        call dmcl_forcing%initialise( vector_space = theta%get_function_space() )
        call invoke( setval_c(dmcl_forcing, 0.0_r_def) )
      end if

      if ( .not.wind_forcing_done) then
        call du_forcing%initialise( vector_space = u%get_function_space() )
        call invoke(setval_c(du_forcing, 0.0_r_def))
      end if

      call vertadvect_forcing_alg( dtheta_forcing, dmv_forcing, dmcl_forcing,    &
                                   du_forcing, theta, mr_n, rho, derived_fields, &
                                   twod_mesh, dt, time_now )
      theta_forcing_done  = .true.
      vapour_forcing_done = .true.
      wind_forcing_done   = .true.
    end if

#ifdef UM_PHYSICS
    if ( .not. vapour_forcing_done ) then
      call dmv_forcing%initialise( vector_space = theta%get_function_space() )
      call invoke( setval_c(dmv_forcing, 0.0_r_def) )
      call dmcl_forcing%initialise( vector_space = theta%get_function_space() )
      call invoke( setval_c(dmcl_forcing, 0.0_r_def) )
    end if
#else
    if (vapour_forcing /= vapour_forcing_none .and. .not. vapour_forcing_done ) then
      call dmv_forcing%initialise( vector_space = theta%get_function_space() )
      call invoke( setval_c(dmv_forcing, 0.0_r_def) )
      call dmcl_forcing%initialise( vector_space = theta%get_function_space() )
      call invoke( setval_c(dmcl_forcing, 0.0_r_def) )
    end if
#endif

    if (vapour_forcing /= vapour_forcing_none) then

      select case(vapour_forcing)

        case(vapour_forcing_profile)

          call vapour_forcing_profile_alg( dmv_forcing, exner_in_wth, time_now )

        case default

          call log_event( 'slow_physics: Incorrect vapour_forcing option', &
                          LOG_LEVEL_ERROR )

      end select

      vapour_forcing_done = .true. ! Collect this increment later on

    end if

#ifdef UM_PHYSICS
    if ( theta_forcing_done .or. vapour_forcing_done ) then
      ! pc2 response to forcing if requested
      if (cloud == cloud_um .and. scheme == scheme_pc2 .and. &
           pc2_force_response) then

        call pc2_force_response_alg(mr_n, theta, derived_fields, cloud_fields, &
                                    dtheta_forcing, dmv_forcing, dmcl_forcing, &
                                    dcfl_forcing, dbcf_forcing, dt)

        vapour_forcing_done = .true.

      end if
    end if
#endif

    if ( LPROF ) call stop_timing( id, 'external_forcing' )
    !
    ! Write out diagnostics (if available)
    !
    if (write_diag .and. use_xios_io) then
      call write_forcing_diagnostics(du_forcing=du_forcing, output_wind_inc=wind_forcing_done)
    end if

  end subroutine external_forcing_alg

end module external_forcing_alg_mod
