!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief   RHS term operations for limited area models.

module lam_rhs_alg_mod

  use constants_mod,               only: r_def, i_def, l_def, str_def
  use model_clock_mod,             only: model_clock_type
  use matrix_vector_kernel_mod,    only: matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
  use dg_inc_matrix_vector_kernel_mod, &
                                   only: dg_inc_matrix_vector_kernel_type
  use sci_enforce_bc_kernel_mod,   only: enforce_bc_kernel_type
  use timing_mod,                  only: start_timing, stop_timing, tik, LPROF
  use derived_config_mod,          only: bundle_size
  use si_operators_alg_mod,        only: get_rho_at_u
  use sci_fem_constants_mod,       only: get_im3_div_fe
  use dycore_constants_mod,        only: get_w2_mass_matrix, &
                                         w2_si_matrix
  use limited_area_constants_mod,  only: get_mask_fe
  use fs_continuity_mod,           only: W2, W3, Wtheta
  use field_mod,                   only: field_type
  use r_solver_field_mod,          only: r_solver_field_type
  use field_collection_mod,        only: field_collection_type
  use operator_mod,                only: operator_type, &
                                         r_solver_operator_type
  use field_indices_mod,           only: igh_u, igh_t, igh_d, igh_p
  use sci_operator_algebra_kernel_mod, only: operator_setval_x_kernel_type
  use copy_field_alg_mod,          only: copy_field

  implicit none

  private
  public :: calc_rhs_lbc
  public :: apply_mask_rhs

contains

  !> @brief   Apply LAM masks to the RHS.
  !> @details Set the RHS to zero outside the limited area model interior.
  !> @param[in,out] rhs     The full RHS, to be used in the linear mixed solver
  !> @param[in]     finest_mesh_name Name of the finest mesh
  subroutine apply_mask_rhs(rhs, finest_mesh_name)

    implicit none

    type(field_type),   intent(inout)  :: rhs(bundle_size)
    character(len=str_def), intent(in) :: finest_mesh_name
    type(field_type), pointer          :: w2_mask     => null(), &
                                          w3_mask     => null(), &
                                          wtheta_mask => null()
    integer(kind=i_def)                :: mesh_id

    mesh_id = rhs(igh_u)%get_mesh_id()

    ! LAM Masks
    w2_mask     => get_mask_fe(W2, mesh_id, finest_mesh_name)
    w3_mask     => get_mask_fe(W3, mesh_id, finest_mesh_name)
    wtheta_mask => get_mask_fe(Wtheta, mesh_id, finest_mesh_name)

    call invoke( inc_X_times_Y( rhs(igh_u),     &
                                w2_mask),       &
                 inc_X_times_Y( rhs(igh_d),     &
                                w3_mask),       &
                 inc_X_times_Y( rhs(igh_p),     &
                                w3_mask),       &
                 inc_X_times_Y( rhs(igh_t),     &
                                wtheta_mask)    )

    nullify( w2_mask, w3_mask, wtheta_mask )

  end subroutine apply_mask_rhs

  !> @brief   Compute the RHS LBC term.
  !> @details Apply the LHS mixed operator to the lateral boundary condition, to
  !>          be used as an additional RHS term, rhs = A(x_b). This code is
  !>          similar to the operator constructor in mixed_operator_alg_mod.x90,
  !>          but noting that x_b is only non-zero for the wind field.
  !>          Since these terms go into the rhs no normalisation is applied here
  !>          (in contrast to the mixed operator) since the normalisation is
  !>          applied for the whole rhs term before the solver is called.
  !> @param[in,out] rhs         RHS term for the mixed solve, to include LBCs
  !> @param[in]     lbc_fields  Field collection containing LBC data
  !> @param[in]     model_clock Time in the model
  !> @param[in]     finest_mesh_name Name of the finest mesh
  !> @param[in]     tau_r Relaxation parameter for density in semi-implicit method
  subroutine calc_rhs_lbc( rhs, lbc_fields, model_clock, finest_mesh_name, &
                           tau_r )

    implicit none

    type(field_type),            intent(inout) :: rhs(bundle_size)
    type(field_collection_type), intent(in)    :: lbc_fields
    class(model_clock_type),     intent(in)    :: model_clock
    character(len=str_def),      intent(in)    :: finest_mesh_name
    real(r_def),                 intent(in)    :: tau_r

    type(field_type),    pointer :: boundary_u => null()
    type(operator_type), pointer :: mm_vel     => null(), &
                                    div        => null()
    type(field_type),    pointer :: mt_lumped_inv => null(), &
                                    m2_diag       => null()
    type(field_type)             :: rho_at_u, &
                                    f_star,   &
                                    u_tmp,    &
                                    r_tmp
    real(r_def),       parameter :: minus_one = -1.0_r_def
    type(field_type),    pointer :: w2_mask     => null(), &
                                    w3_mask     => null(), &
                                    wtheta_mask => null()
    real(r_def)                  :: dt
    real(r_def)                  :: tau_r_dt
    integer(i_def)               :: mesh_id

    type(r_solver_field_type), pointer :: r_solver_rho_at_u => null()
    integer(tik)                 :: id

    if ( LPROF ) call start_timing( id, 'dynamics.rhs_lbc' )

    mesh_id = rhs(igh_u)%get_mesh_id()

    dt = real(model_clock%get_seconds_per_step(), r_def)
    tau_r_dt = tau_r*dt

    ! Get the LBC data
    call lbc_fields%get_field('boundary_u_diff', boundary_u)

    ! LAM Masks
    w2_mask     => get_mask_fe(W2, mesh_id, finest_mesh_name)
    w3_mask     => get_mask_fe(W3, mesh_id, finest_mesh_name)
    wtheta_mask => get_mask_fe(Wtheta, mesh_id, finest_mesh_name)

    ! Obtain operators from runtime constants
    div => get_im3_div_fe(mesh_id)

    ! m2 (or dl) + tau_u*dt*coriolis (lagged if required)
    mm_vel => get_w2_mass_matrix(w2_si_matrix, mesh_id, model_clock)

    ! Obtain operators from SI operators
    r_solver_rho_at_u => get_rho_at_u()
    call rho_at_u%initialise( vector_space = rhs(igh_u)%get_function_space() )
    call copy_field( r_solver_rho_at_u, rho_at_u )
    call f_star%initialise( vector_space = rhs(igh_u)%get_function_space() )
    call u_tmp%initialise( vector_space = rhs(igh_u)%get_function_space() )
    call r_tmp%initialise( vector_space = rhs(igh_d)%get_function_space() )

    call invoke( name = "compute_rhs_lbc",                         &
         ! Initialise field that are incremented
                      setval_c( u_tmp, 0.0_r_def ),                &
                      setval_c( rhs(igh_t), 0.0_r_def ),           &
                      setval_c( rhs(igh_u), 0.0_r_def ),           &
         ! Initialise rhs pressure
                      setval_c( rhs(igh_p), 0.0_r_def ),           &
         ! L_u
                      matrix_vector_kernel_type(   u_tmp,          &
                                                   boundary_u,     &
                                                   mm_vel ),       &
                      inc_aX_plus_Y(               minus_one,      &
                                                   rhs(igh_u),     &
                                                   u_tmp),         &
                      enforce_bc_kernel_type(      rhs(igh_u) ),   &
         ! L_theta - rhs(igh_t) = ptheta2 * boundary_u, but as
         !           boundary_u is only non-zero in the horizontal,
         !           this is zero and hence this step is omitted.
         ! L_rho
                      X_times_Y(                   f_star,         &
                                                   rho_at_u,       &
                                                   boundary_u ),   &
                      dg_matrix_vector_kernel_type(rhs(igh_d),     &
                                                   f_star,         &
                                                   div ),          &
                      inc_a_times_X(               tau_r_dt,       &
                                                   rhs(igh_d) ),   &
         ! Lateral boundaries
                      inc_X_times_Y(               rhs(igh_u),     &
                                                   w2_mask),       &
                      inc_X_times_Y(               rhs(igh_d),     &
                                                   w3_mask),       &
                      inc_X_times_Y(               rhs(igh_t),     &
                                                   wtheta_mask)    &
                      )

    nullify ( boundary_u, w2_mask, w3_mask, wtheta_mask )
    nullify ( div, mt_lumped_inv, m2_diag, mm_vel )
    nullify ( r_solver_rho_at_u )

    if ( LPROF ) call stop_timing( id, 'dynamics.rhs_lbc' )

  end subroutine calc_rhs_lbc

end module lam_rhs_alg_mod
