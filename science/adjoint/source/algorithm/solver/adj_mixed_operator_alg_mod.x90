!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Adjoint of mixed_operator_alg_mod

module adj_mixed_operator_alg_mod

  use base_mesh_config_mod,                        only: prime_mesh_name
  use adj_apply_elim_mixed_lp_operator_kernel_mod, only: adj_apply_elim_mixed_lp_operator_kernel_type
  use adj_apply_mixed_lu_operator_kernel_mod,      only: adj_apply_mixed_lu_operator_kernel_type
  use adj_apply_mixed_operator_kernel_mod,         only: adj_apply_mixed_operator_kernel_type
  use adj_combine_w2_field_kernel_mod,             only: adj_combine_w2_field_kernel_type
  use adj_dg_inc_matrix_vector_kernel_mod,         only: adj_dg_inc_matrix_vector_kernel_type
  use adj_split_w2_field_kernel_mod,               only: adj_split_w2_field_kernel_type
  use boundaries_config_mod,                       only: limited_area
  use constants_mod,                               only: i_def, &
                                                         l_def, &
                                                         r_solver
  use dycore_constants_mod,                        only: w2_si_matrix
  use field_indices_mod,                           only: isol_u, &
                                                         isol_p, &
                                                         isol_w, &
                                                         isol_uv
  use formulation_config_mod,                      only: p2theta_vert
  use fs_continuity_mod,                           only: W2, &
                                                         W3, &
                                                         Wtheta
  use function_space_collection_mod,               only: function_space_collection
  use function_space_mod,                          only: function_space_type
  use integer_field_mod,                           only: integer_field_type
  use limited_area_constants_mod,                  only: get_mask_r_solver
  use log_mod,                                     only: log_event,         &
                                                         LOG_LEVEL_ERROR
  use mesh_mod,                                    only: mesh_type
  use mixed_solver_config_mod,                     only: split_w,                      &
                                                         eliminate_variables,          &
                                                         eliminate_variables_analytic, &
                                                         eliminate_variables_discrete
  use operator_mod,                                only: r_solver_operator_type
  use r_solver_field_mod,                          only: r_solver_field_type
  use sci_enforce_bc_kernel_mod,                   only: enforce_bc_kernel_type
  use sci_geometric_constants_mod,                 only: get_face_selector_ew, &
                                                         get_face_selector_ns
  use sci_linear_operator_mod,                     only: abstract_linear_operator_type
  use sci_r_solver_field_vector_mod,               only: r_solver_field_vector_type
  use si_operators_alg_mod,                        only: get_p2theta,       &
                                                         get_div_star,      &
                                                         get_ptheta2,       &
                                                         get_m3_exner_star, &
                                                         get_p3theta,       &
                                                         get_eliminated_q32
  use solver_constants_mod,                        only: get_w2_mass_matrix_r_solver, &
                                                         get_normalisation_r_solver
  use timing_mod,                                  only: start_timing, &
                                                         stop_timing, &
                                                         tik, LPROF
  use vector_mod,                                  only: abstract_vector_type

  implicit none

  private

  type, public, extends(abstract_linear_operator_type) :: adj_mixed_operator_type
  private
  contains
    procedure, public  :: apply => apply_adj_mixed_operator
    procedure, private :: apply_adj_mixed_operator
    final              :: destroy_adj_mixed_operator
  end type adj_mixed_operator_type

contains

  !> @brief Applies the adjoint mixed operator to the vector.
  !> @param[in]     x Field vector to be read
  !> @param[in,out] y Field vector to be written
  subroutine apply_adj_mixed_operator(self, x, y)

    implicit none

    class(adj_mixed_operator_type), intent(inout)    :: self
    class(abstract_vector_type),    intent(in)       :: x
    class(abstract_vector_type),    intent(inout)    :: y

    type(r_solver_operator_type), pointer :: mm_vel, p2theta, div_star, ptheta2, m3_exner_star, p3theta
    type(r_solver_field_type), pointer    :: mt_lumped_inv, m2_diag
    type(r_solver_field_type)             :: x_uvw, y_uvw
    type(function_space_type), pointer    :: u_fs, t_fs
    integer(i_def)                        :: p_h, p_v
    type(r_solver_field_type), pointer    :: w2_mask, w3_mask
    type(r_solver_field_type)             :: x_t
    real(kind=r_solver), parameter        :: minus_one = -1.0_r_solver
    type(r_solver_operator_type), pointer :: q32_op
    type(r_solver_field_type), pointer    :: xvec_uv, xvec_p, xvec_w
    type(r_solver_field_type), pointer    :: yvec_uv, yvec_p, yvec_w

    type(mesh_type), pointer :: mesh

    logical(kind=l_def) :: optimised_operator

    type(integer_field_type), pointer :: face_selector_ew
    type(integer_field_type), pointer :: face_selector_ns

    type(r_solver_field_vector_type)    :: x_in
    integer(kind=i_def) ::  state_size
    integer(tik)        :: id

    if ( LPROF ) call start_timing( id, 'adj_mixed_solver.operator' )

    ! Extract mesh ID
    select type (y)
    type is (r_solver_field_vector_type)
      mesh => y%vector(isol_u)%get_mesh()
    class default
      call log_event( "adj_mixed_operator_alg_mod: incorrect vector_type argument y", LOG_LEVEL_ERROR )
    end select

    ! LAM Masks
    if (limited_area) then
      w2_mask => get_mask_r_solver( W2, mesh%get_id(), prime_mesh_name )
      w3_mask => get_mask_r_solver( W3, mesh%get_id(), prime_mesh_name )
    end if

    if (split_w) then
      face_selector_ew => get_face_selector_ew(mesh%get_id())
      face_selector_ns => get_face_selector_ns(mesh%get_id())
    end if

    ! Obtain operators from runtime constants
    mt_lumped_inv => get_normalisation_r_solver( Wtheta, mesh%get_id() )
    m2_diag       => get_normalisation_r_solver( W2, mesh%get_id() )
    mm_vel => get_w2_mass_matrix_r_solver( w2_si_matrix, mesh%get_id() )

    ! Obtain operators from SI operators
    p2theta       => get_p2theta()
    div_star      => get_div_star()
    ptheta2       => get_ptheta2()
    m3_exner_star => get_m3_exner_star()
    p3theta       => get_p3theta()

    select type (x)
    type is (r_solver_field_vector_type)
      select type (y)
      type is (r_solver_field_vector_type)
        ! If x%vector or y%vector is used in invokes psyclone assumes they are
        ! of type field_type so instead we use pointers of type
        ! r_solver_field_type to force it to generate the correct code

        ! To keep x IN had to swap x and y
        yvec_uv => x%get_field_from_position(isol_uv)
        yvec_p  => x%get_field_from_position(isol_p)
        xvec_uv => y%get_field_from_position(isol_uv)
        xvec_p  => y%get_field_from_position(isol_p)

        if (split_w) then
          yvec_w  => x%get_field_from_position(isol_w)
          xvec_w  => y%get_field_from_position(isol_w)
        end if

        state_size = 2 ! Default UV + P fields
        if (split_w) state_size = state_size + 1 ! Additional W field

        x_in = r_solver_field_vector_type(state_size)
        call x_in%import_field( yvec_uv, isol_uv )
        call x_in%import_field( yvec_p, isol_p )
        if (split_w) call x_in%import_field( yvec_w, isol_w )

        ! Check if we can use the optimised operator setup
        optimised_operator = (p2theta_vert .and. split_w .and. &
                              eliminate_variables == eliminate_variables_discrete .and. &
                              yvec_uv%get_element_order_h() == 0 .and. &
                              yvec_uv%get_element_order_v() == 0)

        if (.not. optimised_operator) then
          ! Create fields in 3D W2 space
          p_h = x%vector(isol_u)%get_element_order_h()
          p_v = x%vector(isol_u)%get_element_order_v()
           u_fs => function_space_collection%get_fs( mesh, p_h, p_v, W2 )
          call x_uvw%initialise(vector_space=u_fs)
          call y_uvw%initialise(vector_space=u_fs)
          call invoke( setval_c( y_uvw , 0.0_r_solver ), &
                       setval_c( x_uvw , 0.0_r_solver ) )
        end if

        call invoke( setval_c( xvec_p , 0.0_r_solver ),  &
                     setval_c( xvec_uv , 0.0_r_solver ), &
                     setval_c( xvec_w , 0.0_r_solver ) )

        if (.not. optimised_operator) then
          if (split_w) then
            call invoke(adj_split_w2_field_kernel_type( yvec_uv, yvec_w, y_uvw, &
                                                        face_selector_ew,       &
                                                        face_selector_ns ))
          else
            call log_event( 'apply_adj_mixed_operator: .not. split_w not coded', LOG_LEVEL_ERROR )
          end if
        end if

        ! Lateral boundaries
        if (limited_area) call log_event( 'limited_area not coded', LOG_LEVEL_ERROR )

        select case (eliminate_variables)
        case (eliminate_variables_discrete)
          q32_op => get_eliminated_q32()
          if (optimised_operator) then
            call invoke( adj_apply_mixed_operator_kernel_type( yvec_uv, yvec_w, yvec_p,            &
                                                               xvec_uv, xvec_w, xvec_p,            &
                                                               ptheta2, mt_lumped_inv,             &
                                                               mm_vel, p2theta, div_star, m2_diag, &
                                                               m3_exner_star, q32_op, p3theta ),   &
                         setval_c( yvec_uv, 0.0_r_solver ) )
          else
            t_fs => function_space_collection%get_fs( mesh, p_h, p_v, Wtheta )
            call x_t%initialise(vector_space=t_fs)
            call invoke( setval_c( x_t , 0.0_r_solver ),                                                &
                         enforce_bc_kernel_type(y_uvw),                                                 &
                         adj_apply_elim_mixed_lp_operator_kernel_type( yvec_p, x_t, x_uvw,              &
                                                                       xvec_p, m3_exner_star,           &
                                                                       q32_op, p3theta ),               &
                         adj_apply_mixed_lu_operator_kernel_type( y_uvw, x_uvw, x_t, xvec_p,            &
                                                                  mm_vel, p2theta, div_star, m2_diag ), &
                         setval_c( y_uvw, 0.0_r_solver ),                                               &
                         inc_aX_times_Y( minus_one, x_t, mt_lumped_inv ),                               &
                         adj_dg_inc_matrix_vector_kernel_type( x_t, x_uvw, Ptheta2 ),                   &
                         setval_c( x_t, 0.0_r_solver ) )
          end if
        case (eliminate_variables_analytic)
          call log_event( 'apply_adj_mixed_operator: eliminate_variables_analytic not coded', LOG_LEVEL_ERROR )
        case default
          call log_event( 'Invalid mixed solver elimination selected', LOG_LEVEL_ERROR )
        end select

        if (.not. optimised_operator) then
          if (split_w) then
            call invoke( adj_combine_w2_field_kernel_type( x_uvw,xvec_uv, xvec_w,  &
                                                           face_selector_ew,       &
                                                           face_selector_ns ),     &
                         enforce_bc_kernel_type(xvec_w) )
          else
            call log_event( 'apply_adj_mixed_operator: .not. split_w not coded', LOG_LEVEL_ERROR )
          end if
        else
          call invoke( enforce_bc_kernel_type(xvec_w) )
        end if

        ! Call "revert" to reset x to input values (needed for adjoint tests)

        yvec_uv => x_in%get_field_from_position(isol_uv)
        if ( split_w ) yvec_w => x_in%get_field_from_position(isol_w)
        yvec_p => x_in%get_field_from_position(isol_p)

        call revert( x, yvec_uv, yvec_p, yvec_w )

      class default
        call log_event( "mixed_operator_alg_mod: incorrect vector_type argument y", LOG_LEVEL_ERROR )
      end select
    class default
      call log_event( "mixed_operator_alg_mod: incorrect vector_type argument x", LOG_LEVEL_ERROR )
    end select

    if ( LPROF ) call stop_timing( id, 'adj_mixed_solver.operator' )

  end subroutine apply_adj_mixed_operator

  !> @brief Local subroutine used to reset x to input values (needed for tests)
  subroutine revert( x, yvec_uv, yvec_p, yvec_w )

    implicit none

    class(abstract_vector_type) :: x
    type(r_solver_field_type)   :: yvec_uv, yvec_p, yvec_w

    select type (x)
    type is (r_solver_field_vector_type)

      call x%import_field( yvec_uv, isol_uv )
      call x%import_field( yvec_w, isol_w )
      call x%import_field( yvec_p, isol_p )

    class default
    end select

  end

  !> @brief Destructor for the mixed operator
  subroutine destroy_adj_mixed_operator(self)

    implicit none

    type(adj_mixed_operator_type), intent(inout) :: self

  end subroutine destroy_adj_mixed_operator

end module adj_mixed_operator_alg_mod
