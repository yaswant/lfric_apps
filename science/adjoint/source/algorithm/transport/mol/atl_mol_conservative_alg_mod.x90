!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains ADJ. MOL routine for conservative transport of fields.

module atl_mol_conservative_alg_mod

  ! Infrastructure
  use constants_mod,                   only: r_def, i_def, l_def
  use field_mod,                       only: field_type
  use log_mod,                         only: log_event,         &
                                             LOG_LEVEL_ERROR,   &
                                             LOG_LEVEL_INFO
  use mesh_mod,                        only: mesh_type
  use operator_mod,                    only: operator_type
  use timing_mod,                      only: start_timing, stop_timing, &
                                             tik, LPROF

  ! Algorithms and transport code
  use advective_and_flux_alg_mod,      only: advective_and_flux_alg
  use atl_advective_and_flux_alg_mod,  only: atl_advective_and_flux_alg
  use end_of_transport_step_alg_mod,   only: end_of_conservative_step_alg
  use atl_end_transport_step_alg_mod,  only: atl_end_conservative_step_alg
  use flux_precomputations_alg_mod,    only: flux_precomputations_type
  use runge_kutta_init_mod,            only: get_rk_transport_weights
  use split_transport_utils_mod,       only: get_num_split_steps, &
                                             get_splitting_direction
  use transport_constants_mod,         only: get_directional_im3_div
  use transport_controller_mod,        only: transport_controller_type
  use tl_transport_controller_mod,     only: tl_transport_controller_type
  use transport_counter_mod,           only: transport_counter_type
  use transport_metadata_mod,          only: transport_metadata_type
  use wind_precomputations_alg_mod,    only: wind_precomputations_type

  ! Kernels
  use dg_matrix_vector_kernel_mod,     only: dg_matrix_vector_kernel_type
  use adj_dg_matrix_vector_kernel_mod, only: adj_dg_matrix_vector_kernel_type

  ! Configuration
  use boundaries_config_mod,           only: limited_area
  use base_mesh_config_mod,            only: topology, topology_non_periodic
  use transport_config_mod,            only: runge_kutta_method, &
                                             dry_field_name,     &
                                             operators,          &
                                             operators_fem

  implicit none

  public  :: atl_mol_conservative_alg

  contains

  !=============================================================================
  !> @brief Adjoint of tangent linear transport (conservative-form) with the MOL scheme.
  !> @param[in,out] field_np1   ACTIVE  Field at the end of the time step
  !> @param[in,out] field       ACTIVE  Field at the start of the transport step
  !> @param[in]     ls_field    PASSIVE Field at the start of the transport step
  !> @param[in,out] tl_transport_controller
  !!                            Object controlling transport
  subroutine atl_mol_conservative_alg( field_np1, field, ls_field, &
                                       tl_transport_controller )

    implicit none

    ! Arguments
    type(field_type),                   intent(inout) :: field_np1
    type(field_type),                   intent(inout) :: field
    type(field_type),                      intent(in) :: ls_field
    type(tl_transport_controller_type), intent(inout) :: tl_transport_controller

    ! Internal variables
    integer(kind=i_def)                      :: mesh_id
    integer(kind=i_def)                      :: stage, s, direction
    integer(kind=i_def)                      :: nstage, substep
    integer(kind=i_def)                      :: number_substeps
    integer(kind=i_def)                      :: step
    integer(kind=i_def)                      :: splitting
    real(kind=r_def)                         :: dt_mol_substep
    logical(kind=l_def)                      :: final_rk_stage
    logical(kind=l_def)                      :: final_substep
    logical(kind=l_def)                      :: final_split_step
    logical(kind=l_def)                      :: do_flux
    logical(kind=l_def)                      :: do_advective
    type(mesh_type),                 pointer :: mesh
    type(operator_type),             pointer :: div
    type(field_type)                         :: flux
    type(field_type)                         :: adv_inc
    type(field_type)                         :: ls_sum_flux
    type(field_type)                         :: sum_flux_pert_wind
    type(field_type)                         :: sum_flux_ls_wind
    type(field_type)                         :: rhs, field_n
    type(field_type)                         :: ls_field_np1, ls_field_n
    type(field_type)                         :: flux_step
    type(field_type)                         :: flux_step_ls_wind
    type(field_type)                         :: flux_step_pert_wind
    type(field_type)                         :: rhs_field
    type(field_type),                pointer :: advecting_wind
    type(field_type),                pointer :: ls_advecting_wind
    type(field_type),            allocatable :: stored_ls_field(:,:)
    type(field_type),            allocatable :: rk_field(:)
    real(kind=r_def),            allocatable :: rk_weights(:,:)
    type(transport_metadata_type),   pointer :: transport_metadata
    type(transport_counter_type),    pointer :: transport_counter
    type(transport_controller_type), pointer :: transport_controller
    type(transport_controller_type), pointer :: ls_transport_controller
    type(transport_controller_type), pointer :: pert_transport_controller
    type(wind_precomputations_type), pointer :: ls_wind_precomputations
    type(wind_precomputations_type), pointer :: pert_wind_precomputations
    type(flux_precomputations_type), pointer :: flux_precomputations
    type(flux_precomputations_type), pointer :: ls_wind_flux_precomp
    type(flux_precomputations_type), pointer :: pert_wind_flux_precomp
    integer(tik)                             :: id

    if ( LPROF ) call start_timing( id, 'atl_transport.mol_conservative' )

    ! ------------------------------------------------------------------------ !
    ! Extract transport objects and initialise temporary fields
    ! ------------------------------------------------------------------------ !
    mesh => field%get_mesh()
    mesh_id = field%get_mesh_id()
    transport_controller => tl_transport_controller%get_ls_wind_ls_rho_controller()
    ls_transport_controller => tl_transport_controller%get_ls_wind_pert_rho_controller()
    pert_transport_controller => tl_transport_controller%get_pert_wind_ls_rho_controller()
    transport_metadata => pert_transport_controller%get_transport_metadata()
    transport_counter => pert_transport_controller%get_transport_counter()
    flux_precomputations => transport_controller%get_flux_precomputations()
    ls_wind_flux_precomp => ls_transport_controller%get_flux_precomputations()
    pert_wind_flux_precomp => pert_transport_controller%get_flux_precomputations()
    ls_wind_precomputations => ls_transport_controller%get_wind_precomputations()
    pert_wind_precomputations => pert_transport_controller%get_wind_precomputations()

    step = transport_counter%get_split_step_of_substep_counter()
    splitting = transport_metadata%get_splitting()
    direction = get_splitting_direction(splitting, step)

    advecting_wind => pert_wind_precomputations%get_wind(mesh%get_id(), direction)
    ls_advecting_wind => ls_wind_precomputations%get_wind(mesh%get_id(), direction)
    number_substeps = ls_wind_precomputations%get_number_mol_substeps(         &
            mesh%get_id(), direction, splitting, step                          &
    )
    dt_mol_substep = ls_wind_precomputations%get_dt_mol_substep(               &
            mesh%get_id(), direction, splitting, step                          &
    )
    div => get_directional_im3_div(mesh_id, direction)

    call get_rk_transport_weights(nstage, rk_weights, runge_kutta_method)
    allocate( rk_field(nstage) )
    allocate( stored_ls_field(number_substeps,nstage) )

    do stage = 1, nstage
      call rk_field(stage)%initialise(field%get_function_space())
      do substep = 1, number_substeps
        call stored_ls_field(substep, stage)%initialise(field%get_function_space())
      end do
    end do
    call rhs_field%initialise( field%get_function_space() )

    call flux%initialise(advecting_wind%get_function_space())
    call flux_step%initialise(advecting_wind%get_function_space())
    call flux_step_ls_wind%initialise(advecting_wind%get_function_space())
    call flux_step_pert_wind%initialise(advecting_wind%get_function_space())
    call rhs%initialise(field%get_function_space())
    call field_n%initialise(field%get_function_space())
    call adv_inc%initialise(field%get_function_space())
    call sum_flux_ls_wind%initialise(advecting_wind%get_function_space())
    call sum_flux_pert_wind%initialise(advecting_wind%get_function_space())
    call ls_sum_flux%initialise(advecting_wind%get_function_space())

    call ls_field%copy_field_properties(ls_field_np1)

    call invoke( setval_c( field_n, 0.0_r_def ),            &
                 setval_X( ls_field_np1, ls_field ),        &
                 setval_c( sum_flux_pert_wind, 0.0_r_def ), &
                 setval_c( sum_flux_ls_wind, 0.0_r_def ),   &
                 setval_c( ls_sum_flux, 0.0_r_def ) )

    ! Can use either transport_counter or tl_transport_counter to determine this
    ! as both should give the same value
    final_split_step = ( transport_counter%get_split_step_of_substep_counter() &
                         == get_num_split_steps(transport_metadata%get_splitting()) )

    ! ======================================================================== !
    !                    Linearisation state
    !
    !       This calculates the values of ls_field. These are stored as an
    !       array for each substep and each RK stage to use in the perturbation
    ! ======================================================================== !
    ! ------------------------------------------------------------------------ !
    ! Start of substepping loop
    ! ------------------------------------------------------------------------ !
    ls_substep_loop: do substep = 1, number_substeps

      final_substep = ( substep == number_substeps )

      ! Reset field_n ready for the this substep
      call ls_field_np1%copy_field_properties(ls_field_n)
      call invoke( setval_X(ls_field_n, ls_field_np1) )

      ls_stage_loop: do stage = 1, nstage

        final_rk_stage = ( stage == nstage )

        ! Store values for use in the perturbation code. This is done before
        ! advecting so as to pick up the correct linearisation state
        call invoke( setval_X(stored_ls_field(substep,stage), ls_field_np1) )

        ! Compute the field for this stage:
        ! rhs_field = sum(s=1,stage): a(stage,s)*field^(s)
        call invoke( setval_X( rk_field(stage), ls_field_np1 ), &
                     setval_c( rhs_field, 0.0_r_def ) )
        do s = 1, stage
          call invoke( inc_X_plus_bY( rhs_field, rk_weights(stage,s), rk_field(s) ) )
        end do

        ! -------------------------------------------------------------------- !
        ! Apply advection / flux operator depending on formulation
        ! -------------------------------------------------------------------- !
        if ( operators == operators_fem ) then
          call log_event('A.T.L.: FEM operators in mol conservative not ' // &
                         'yet implemented', LOG_LEVEL_ERROR)

        else if (.not. final_rk_stage) then
          ! Advective-then-flux form but not last stage: just advective
          do_flux = .false.
          do_advective = .true.

        else if ( (.not. final_split_step) .or. (.not. final_substep) ) then
          ! Advective-then-flux form and last stage: both advective and flux
          do_flux = .true.
          do_advective = .true.

        else
          ! Last stage of last substep for either 3D MoL or last step of split scheme
          ! Just use flux form
          do_flux = .true.
          do_advective = .false.

        end if

        call advective_and_flux_alg(flux_step, adv_inc, rhs_field, ls_field_n, &
                                    ls_advecting_wind, direction,              &
                                    transport_metadata, final_rk_stage,        &
                                    dt_mol_substep, do_flux, do_advective)

        if ( do_flux ) then
          call invoke( dg_matrix_vector_kernel_type(rhs, flux_step, div) )
        end if
        if ( do_advective ) then
          call invoke( X_minus_bY(ls_field_np1, ls_field_n,                    &
                                  dt_mol_substep, adv_inc) )
        end if

        ! -------------------------------------------------------------------- !
        ! Blending zone update
        ! -------------------------------------------------------------------- !
        if ( limited_area .and. topology == topology_non_periodic ) then
          call log_event('T.L.: limited area in mol conservative not ' // &
                         'yet implemented', LOG_LEVEL_ERROR)
        end if

      end do ls_stage_loop

      ! Increment the total flux by the substep flux
      call invoke( inc_X_plus_bY(ls_sum_flux, dt_mol_substep, flux_step) )

      ! ---------------------------------------------------------------------- !
      ! Blending zone update
      ! ---------------------------------------------------------------------- !
      if ( limited_area .and. topology == topology_non_periodic ) then
        call log_event('T.L.: limited area in mol conservative not ' // &
                        'yet implemented', LOG_LEVEL_ERROR)
      end if
    end do ls_substep_loop

    ! ------------------------------------------------------------------------ !
    ! End of step
    ! ------------------------------------------------------------------------ !

    ! If this is the final step, field_np1 will be computed here from the fluxes
    ! over the whole transport step
    ! If this is not the final step, field_np1 already includes the *advective*
    ! increment, and may be adjusted to enforce min value or in blending zone
    call end_of_conservative_step_alg(                                         &
            ls_field_np1, ls_field, ls_sum_flux, flux_precomputations,         &
            transport_counter, transport_metadata                              &
    )

    ! ======================================================================== !
    !                    Perturbation
    !
    !   Repeat the calculation, but now for the adjoint - adding in
    !   the values of ls_field_np1(substep,stage) obtained in the
    !   linearisation stage stage
    ! ======================================================================== !

    ! ------------------------------------------------------------------------ !
    ! End of step
    ! ------------------------------------------------------------------------ !

    ! If this is the final step, field_np1 will be computed here from the fluxes
    ! over the whole transport step
    ! If this is not the final step, field_np1 already includes the *advective*
    ! increment, and may be adjusted to enforce min value or in blending zone
    call atl_end_conservative_step_alg(                                        &
            field_np1, field, sum_flux_ls_wind, sum_flux_pert_wind,            &
            ls_wind_flux_precomp, pert_wind_flux_precomp,                      &
            transport_counter, transport_metadata                              &
    )

    ! Init values of intermediate adjoint fields
    call invoke( setval_c( rhs_field, 0.0_r_def ),           &
                 setval_c( rhs, 0.0_r_def ),                 &
                 setval_c( flux_step_pert_wind, 0.0_r_def ), &
                 setval_c( flux_step_ls_wind, 0.0_r_def ),   &
                 setval_c( adv_inc, 0.0_r_def ) )
    do stage = 1, nstage
      call invoke( setval_c( rk_field(stage), 0.0_r_def ) )
    end do

    ! ------------------------------------------------------------------------ !
    ! Start of substepping loop
    ! ------------------------------------------------------------------------ !
    substep_loop: do substep = number_substeps, 1, -1

      final_substep = ( substep == number_substeps )

      ! ---------------------------------------------------------------------- !
      ! Blending zone update
      ! ---------------------------------------------------------------------- !
      if ( limited_area .and. topology == topology_non_periodic ) then
        call log_event('ATL.: limited area in mol conservative not ' // &
                        'yet implemented', LOG_LEVEL_ERROR)
      end if

      ! Increment the total flux by the substep flux
      call invoke( inc_X_plus_bY(flux_step_pert_wind, dt_mol_substep, sum_flux_pert_wind), &
                   inc_X_plus_bY(flux_step_ls_wind, dt_mol_substep, sum_flux_ls_wind) )

      stage_loop: do stage = nstage, 1, -1

        final_rk_stage = ( stage == nstage )

        ! -------------------------------------------------------------------- !
        ! Blending zone update
        ! -------------------------------------------------------------------- !
        if ( limited_area .and. topology == topology_non_periodic ) then
          call log_event('ATL.: limited area in mol conservative not ' // &
                         'yet implemented', LOG_LEVEL_ERROR)
        end if

        ! -------------------------------------------------------------------- !
        ! Apply advection / flux operator depending on formulation
        ! -------------------------------------------------------------------- !
        if ( operators == operators_fem ) then
          call log_event('ATL.: FEM operators in mol conservative not ' // &
                         'yet implemented', LOG_LEVEL_ERROR)

        else if (.not. final_rk_stage) then
          ! Advective-then-flux form but not last stage: just advective
          do_flux = .false.
          do_advective = .true.

        else if ( (.not. final_split_step) .or. (.not. final_substep) ) then
          ! Advective-then-flux form and last stage: both advective and flux
          do_flux = .true.
          do_advective = .true.

        else
          ! Last stage of last substep for either 3D MoL or last step of split scheme
          ! Just use flux form
          do_flux = .true.
          do_advective = .false.

        end if

        if ( do_flux ) then
          call invoke( adj_dg_matrix_vector_kernel_type(rhs, flux_step_pert_wind, div), &
                       adj_dg_matrix_vector_kernel_type(rhs, flux_step_ls_wind, div) )
        end if
        if ( do_advective ) then
          call invoke( inc_X_minus_bY( adv_inc, dt_mol_substep, field_np1 ), &
                       inc_X_plus_Y( field_n, field_np1 ),                   &
                       setval_c( field_np1, 0.0_r_def ) )
        end if

        call atl_advective_and_flux_alg(                                       &
                flux_step_ls_wind, flux_step_pert_wind, adv_inc,               &
                rhs_field, advecting_wind,                                     &
                stored_ls_field(substep,stage), ls_advecting_wind,             &
                direction, transport_metadata, final_rk_stage,                 &
                dt_mol_substep, do_flux, do_advective                          &
        )

        do s = stage, 1, -1
          call invoke( inc_X_plus_bY( rk_field(s), rk_weights(stage,s), rhs_field ) )
        end do

        ! Compute the field for this stage:
        ! rhs_field = sum(s=1,stage): a(stage,s)*field^(s)
        call invoke( setval_c( rhs_field, 0.0_r_def ),           &
                     inc_X_plus_Y( field_np1, rk_field(stage) ), &
                     setval_c( rk_field(stage), 0.0_r_def ) )

      end do stage_loop

      ! Reset field_n ready for the this substep
      call invoke( inc_X_plus_Y( field_np1, field_n ), &
                   setval_c( field_n, 0.0_r_def ) )

    end do substep_loop

    call invoke( inc_X_plus_Y( field, field_np1 ), &
                 setval_c( field_np1, 0.0_r_def) )

    if ( allocated(rk_field) ) deallocate(rk_field)
    if ( allocated(rk_weights) ) deallocate(rk_weights)
    if ( allocated(stored_ls_field) ) deallocate(stored_ls_field)

    if ( LPROF ) call stop_timing( id, 'atl_transport.mol_conservative' )

  end subroutine atl_mol_conservative_alg

end module atl_mol_conservative_alg_mod
