!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief   The tangent linear test for the sample pressure kernel
!!         (Taylor remainder convergence).
!>@details Test whether a section of tangent linear code is tangent linear
!!         to the corresponding section of nonlinear code, for the
!!         sample pressure kernel, using the Taylor remainder
!!         convergence test.
module tl_test_sample_eos_pressure_mod

  use sci_assign_field_random_kernel_mod, &
                                      only: assign_field_random_kernel_type
  use constants_mod,                  only: i_def, r_def, str_def
  use field_array_mod,                only: field_array_type
  use sci_field_bundle_builtins_mod,  only: clone_bundle
  use field_mod,                      only: field_type
  use mesh_mod,                       only: mesh_type
  use field_collection_mod,           only: field_collection_type
  use finite_element_config_mod,      only: element_order_h, element_order_v
  use fs_continuity_mod,              only: W3, Wtheta
  use function_space_collection_mod,  only: function_space_collection
  use driver_modeldb_mod,             only: modeldb_type
  use moist_dyn_mod,                  only: num_moist_factors, gas_law
  use planet_config_mod,              only: cp
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO
  use sample_eos_pressure_kernel_mod, only: sample_eos_pressure_kernel_type
  use tl_sample_eos_pressure_kernel_mod, &
                                      only: tl_sample_eos_pressure_kernel_type
  use tl_test_convergence_rate_check, only: convergence_rate_check

  implicit none

  private
  public test_sample_eos_pressure

  contains

  !> @brief Test the tangent linear for the sample_eos_pressure kernel.
  !> @param[in] modeldb    The working data set for a model run
  !> @param[in] mesh       The current 3d mesh
  !> @param[in] twod_mesh  The current 2d mesh
  subroutine test_sample_eos_pressure( modeldb, &
                                       mesh,    &
                                       twod_mesh )
    implicit none

    type(mesh_type), pointer, intent(in)   :: mesh
    type(mesh_type), pointer, intent(in)   :: twod_mesh
    type(modeldb_type), target, intent(in) :: modeldb

    character(str_def) :: label = "sample_eos_pressure"

    type(field_collection_type ), pointer :: prognostic_fields => null()
    type(field_collection_type ), pointer :: ls_fields

    ! Input
    type(field_type), pointer :: n_rho => null()
    type(field_type), pointer :: ls_rho => null()
    type(field_type) :: p_rho
    type(field_type), pointer :: n_theta => null()
    type(field_type), pointer :: ls_theta => null()
    type(field_type) :: p_theta
    type(field_type), pointer :: n_moist_dyn(:) => null()
    type(field_type), pointer :: ls_moist_dyn(:) => null()
    type(field_type), dimension(num_moist_factors) :: p_moist_dyn

    ! Output
    type(field_type) :: n1_exner
    type(field_type) :: n2_exner
    type(field_type) :: p_exner

    ! Test
    type(field_type) :: diff
    type(field_type) :: random_rho
    type(field_type) :: random_theta
    type(field_type), dimension(num_moist_factors) :: random_moist_dyn

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: moist_dyn_array => null()
    type(field_array_type), pointer      :: ls_moist_dyn_array => null()

    real(r_def) :: norm_diff, norm_diff_prev
    real(r_def) :: gamma

    integer :: n, i
    real(r_def), parameter :: tol = 1.e-3_r_def

    call log_event( "TL Test: " // trim(label), &
                     LOG_LEVEL_INFO )

    prognostic_fields => modeldb%fields%get_field_collection( &
                                           "prognostic_fields")
    ls_fields => modeldb%fields%get_field_collection("ls_fields")

    ! Input fields
    call prognostic_fields%get_field('rho', n_rho)
    call ls_fields%get_field('ls_rho', ls_rho)
    call p_rho%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call prognostic_fields%get_field('theta', n_theta)
    call ls_fields%get_field('ls_theta', ls_theta)
    call p_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, Wtheta) )
    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("moist_dyn", moist_dyn_array)
    n_moist_dyn => moist_dyn_array%bundle
    call moisture_fields%get_field("ls_moist_dyn", ls_moist_dyn_array)
    ls_moist_dyn => ls_moist_dyn_array%bundle
    call clone_bundle(n_moist_dyn, p_moist_dyn, num_moist_factors)

    ! Output fields
    call n1_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call n2_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call p_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )

    ! Test fields
    call random_rho%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call random_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, Wtheta) )
    call clone_bundle(n_moist_dyn, random_moist_dyn, num_moist_factors)
    call diff%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )

    ! Taylor Remainder Convergence Test
    call invoke( setval_C( n1_exner, 0.0_r_def ) )
    call invoke( sample_eos_pressure_kernel_type(      &
                   n1_exner, ls_rho, ls_theta,      &
                   ls_moist_dyn(gas_law)) )

    call invoke( assign_field_random_kernel_type( random_rho, 1.0_r_def ) )
    call invoke( assign_field_random_kernel_type( random_theta, 1.0_r_def  ) )
    do i = 1, num_moist_factors
      call invoke( assign_field_random_kernel_type( random_moist_dyn(i), 1.0_r_def  ) )
    end do

    gamma = 1.e-3_r_def

    do n=1,2
      gamma = gamma/2.0_r_def

      call invoke( setval_C( n2_exner, 0.0_r_def ),                 &
                   setval_C( p_exner, 0.0_r_def ),                  &
                   a_times_X( p_theta, gamma, random_theta ),       &
                   setval_X( n_theta, ls_theta ),                   &
                   inc_X_plus_Y( n_theta, p_theta ),                &
                   a_times_X( p_rho, gamma, random_rho ),           &
                   setval_X( n_rho, ls_rho ),                       &
                   inc_X_plus_Y( n_rho, p_rho ) )

      do i = 1, num_moist_factors
        call invoke( a_times_X( p_moist_dyn(i), gamma,               &
                                random_moist_dyn(i) ),               &
                     setval_X( n_moist_dyn(i), ls_moist_dyn(i) ),    &
                     inc_X_plus_Y( n_moist_dyn(i), p_moist_dyn(i) ) )
      end do

      call invoke( sample_eos_pressure_kernel_type(      &
                         n2_exner, n_rho, n_theta,       &
                         n_moist_dyn(gas_law)) )

      call invoke( tl_sample_eos_pressure_kernel_type(           &
                         p_exner, p_rho, p_theta,                &
                         p_moist_dyn(gas_law), ls_rho, ls_theta, &
                         ls_moist_dyn(gas_law) ) )

      call invoke( X_minus_Y( diff, n2_exner, n1_exner ),   &
                   inc_X_minus_Y( diff, p_exner ),          &
                   X_innerproduct_X( norm_diff, diff ) )

      write( log_scratch_space, '(A, E32.12, A, E32.12)' ) &
             'gamma = ', gamma , ' norm = ', norm_diff

      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      if (n == 2) then
        call convergence_rate_check( norm_diff, norm_diff_prev, &
                                     label, tol=tol )
      end if

      norm_diff_prev = norm_diff
    end do

  end subroutine test_sample_eos_pressure

end module tl_test_sample_eos_pressure_mod
