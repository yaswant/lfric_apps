!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief   The tangent linear test for the semi-implicit timestepping
!!         (Taylor remainder convergence).
!>@details Test whether a section of tangent linear code is tangent linear
!!         to the corresponding section of nonlinear code, for the semi
!!         implicit algorithm, using the Taylor remainder convergence test.
module tl_test_semi_imp_alg_mod

  use constants_mod,                  only: i_def, r_def, str_def
  use field_array_mod,                only: field_array_type
  use field_mod,                      only: field_type
  use sci_field_bundle_builtins_mod,  only: clone_bundle
  use field_collection_mod,           only: field_collection_type
  use function_space_collection_mod,  only: function_space_collection
  use finite_element_config_mod,      only: element_order_h, element_order_v
  use formulation_config_mod,         only: moisture_formulation,    &
                                            moisture_formulation_dry
  use fs_continuity_mod,              only: W2, W3, Wtheta
  use driver_modeldb_mod,             only: modeldb_type
  use moist_dyn_mod,                  only: num_moist_factors
  use mr_indices_mod,                 only: nummr
  use timestepping_config_mod,        only: dt
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO
  use mesh_mod,                       only: mesh_type
  use tl_si_timestep_alg_mod,         only: tl_semi_implicit_alg_init, &
                                            tl_semi_implicit_alg_step, &
                                            tl_semi_implicit_alg_final
  use semi_implicit_timestep_alg_mod, only: semi_implicit_timestep_type
  use semi_implicit_solver_alg_mod,   only: semi_implicit_solver_alg_final
  use si_operators_alg_mod,           only: final_si_operators
  use timestep_method_mod,            only: timestep_method_type
  use moist_dyn_factors_alg_mod,      only: moist_dyn_factors_alg
  use tl_moist_dyn_factors_alg_mod,   only: tl_moist_dyn_factors_alg
  use tl_test_convergence_rate_check, only: array_convergence_rate_check

  implicit none

  private
  public test_semi_imp_alg

  contains

  !> @brief Test the tangent linear semi-implicit algorithm
  !> @param[in] modeldb       The working data set for a model run
  !> @param[in] mesh          The current 3d mesh
  !> @param[in] twod_mesh     The current 2d mesh
  !>
  subroutine test_semi_imp_alg( modeldb, &
                                mesh,    &
                                twod_mesh )

    implicit none

    type(mesh_type), pointer, intent(in) :: mesh
    type(mesh_type), pointer, intent(in) :: twod_mesh

    type(modeldb_type), target, intent(inout) :: modeldb

    class(timestep_method_type), pointer :: semi_implicit_timestep_method => null()

    character(str_def) :: label = "semi_imp_alg"

    type( field_collection_type ), pointer :: prognostic_fields => null()
    type( field_collection_type ), pointer :: ls_fields
    type( field_collection_type ), pointer :: diagnostic_fields => null()
    type( field_type ),            pointer :: mr(:) => null()
    type( field_type ),            pointer :: ls_mr(:) => null()
    type( field_collection_type ), pointer :: adv_tracer_all_outer
    type( field_collection_type ), pointer :: adv_tracer_last_outer
    type( field_collection_type ), pointer :: con_tracer_all_outer
    type( field_collection_type ), pointer :: con_tracer_last_outer
    type( field_collection_type ), pointer :: derived_fields
    type( field_collection_type ), pointer :: radiation_fields
    type( field_collection_type ), pointer :: microphysics_fields
    type( field_collection_type ), pointer :: electric_fields
    type( field_collection_type ), pointer :: orography_fields
    type( field_collection_type ), pointer :: turbulence_fields
    type( field_collection_type ), pointer :: convection_fields
    type( field_collection_type ), pointer :: cloud_fields
    type( field_collection_type ), pointer :: surface_fields
    type( field_collection_type ), pointer :: soil_fields
    type( field_collection_type ), pointer :: snow_fields
    type( field_collection_type ), pointer :: chemistry_fields => null()
    type( field_collection_type ), pointer :: aerosol_fields
    type( field_collection_type ), pointer :: stph_fields
    type( field_collection_type ), pointer :: lbc_fields


    type(field_type), pointer :: ls_u => null()
    type(field_type), pointer :: ls_rho => null()
    type(field_type), pointer :: ls_theta => null()
    type(field_type), pointer :: ls_exner => null()
    type(field_type), pointer :: ls_moist_dyn(:) => null()

    type(field_type), pointer :: u => null()
    type(field_type), pointer :: rho => null()
    type(field_type), pointer :: theta => null()
    type(field_type), pointer :: exner => null()
    type(field_type), pointer :: moist_dyn(:) => null()

    type(field_type), dimension(num_moist_factors) :: p_moist_dyn
    type(field_type), dimension(num_moist_factors) :: b_moist_dyn

    type(field_type), dimension(nummr) :: p_mr
    type(field_type), dimension(nummr) :: b_mr
    type(field_type), dimension(nummr) :: r_mr
    type(field_type), dimension(nummr) :: diff_mr
    type(field_type) :: p_u, p_rho, p_theta, p_exner
    type(field_type) :: b_u, b_rho, b_theta, b_exner
    type(field_type) :: r_u, r_rho, r_theta, r_exner
    type(field_type) :: diff_u, diff_rho, diff_theta, diff_exner

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: mr_array => null()
    type(field_array_type), pointer      :: moist_dyn_array => null()
    type(field_array_type), pointer      :: ls_mr_array => null()
    type(field_array_type), pointer      :: ls_moist_dyn_array => null()

    real(r_def) :: gamma_u, gamma_rho, gamma_exner, gamma_theta
    real(r_def) :: gamma_mr
    real(r_def) :: norm_u, norm_rho, norm_exner, norm_theta
    real(r_def) :: norm_mr, norm_mr_tmp
    integer(i_def), parameter :: n_variables = 5
    real(r_def) :: array_norm(n_variables), array_norm_prev(n_variables)
    character(str_def) :: array_names(n_variables)

    real(r_def), parameter :: tol = 5.e-2_r_def
    real(r_def), parameter :: indiv_tol = 5.e-1_r_def
    real(r_def), parameter :: dtemp_encorr = 0.0_r_def

    integer :: n, i

    call log_event( "TL Test: " // trim(label), &
                     LOG_LEVEL_INFO )


    ls_fields => modeldb%fields%get_field_collection("ls_fields")
    prognostic_fields => modeldb%fields%get_field_collection( &
                                           "prognostic_fields")
    diagnostic_fields => modeldb%fields%get_field_collection( &
                                           "diagnostic_fields")

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("mr", mr_array)
    call moisture_fields%get_field("moist_dyn", moist_dyn_array)
    mr => mr_array%bundle
    moist_dyn => moist_dyn_array%bundle
    call moisture_fields%get_field("ls_mr", ls_mr_array)
    call moisture_fields%get_field("ls_moist_dyn", ls_moist_dyn_array)
    ls_mr => ls_mr_array%bundle
    ls_moist_dyn => ls_moist_dyn_array%bundle
    adv_tracer_all_outer => modeldb%fields%get_field_collection("adv_tracer_all_outer")
    adv_tracer_last_outer => modeldb%fields%get_field_collection("adv_tracer_last_outer")
    con_tracer_all_outer => modeldb%fields%get_field_collection("con_tracer_all_outer")
    con_tracer_last_outer => modeldb%fields%get_field_collection("con_tracer_last_outer")
    derived_fields => modeldb%fields%get_field_collection("derived_fields")
    radiation_fields => modeldb%fields%get_field_collection("radiation_fields")
    microphysics_fields => modeldb%fields%get_field_collection("microphysics_fields")
    electric_fields => modeldb%fields%get_field_collection("electric_fields")
    orography_fields => modeldb%fields%get_field_collection("orography_fields")
    turbulence_fields => modeldb%fields%get_field_collection("turbulence_fields")
    convection_fields => modeldb%fields%get_field_collection("convection_fields")
    cloud_fields => modeldb%fields%get_field_collection("cloud_fields")
    surface_fields => modeldb%fields%get_field_collection("surface_fields")
    soil_fields => modeldb%fields%get_field_collection("soil_fields")
    snow_fields => modeldb%fields%get_field_collection("snow_fields")
    chemistry_fields => modeldb%fields%get_field_collection("chemistry_fields")
    aerosol_fields => modeldb%fields%get_field_collection("aerosol_fields")
    stph_fields => modeldb%fields%get_field_collection("stph_fields")
    lbc_fields => modeldb%fields%get_field_collection("lbc_fields")

    ! Linearisation State
    call ls_fields%get_field('ls_u', ls_u)
    call ls_fields%get_field('ls_rho', ls_rho)
    call ls_fields%get_field('ls_theta', ls_theta)
    call ls_fields%get_field('ls_exner', ls_exner)

    ! Perturbation
    call prognostic_fields%get_field('u', u)
    call prognostic_fields%get_field('rho', rho)
    call prognostic_fields%get_field('theta', theta)
    call prognostic_fields%get_field('exner', exner)

    call p_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W2) )
    call p_rho%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call p_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call p_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, Wtheta) )

    call b_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W2) )
    call b_rho%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call b_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call b_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, Wtheta) )

    call r_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W2) )
    call r_rho%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call r_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call r_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, Wtheta) )

    call diff_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W2) )
    call diff_rho%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call diff_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )
    call diff_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, Wtheta) )

    call clone_bundle(moist_dyn, p_moist_dyn, num_moist_factors)
    call clone_bundle(moist_dyn, b_moist_dyn, num_moist_factors)

    call clone_bundle(mr, p_mr, nummr)
    call clone_bundle(mr, r_mr, nummr)
    call clone_bundle(mr, b_mr, nummr)
    call clone_bundle(mr, diff_mr, nummr)

    ! Set the 'random data' to be the perturbation
    call invoke( name = "copy_fields_to_state",   &
                 setval_X(r_u, u    ), &
                 setval_X(r_exner, exner    ), &
                 setval_X(r_theta, theta), &
                 setval_X(r_rho, rho  ) )

    ! Overwrite the moisture fields with potential temperature
    !
    ! Note: The perturbation fields are read in from file. However the
    ! moisture perturbation fields have values close to zero (especially
    ! at upper levels) and this gives an inaccurate linearisation test. Using
    ! potential temperature is an easy fix to create a realistic 'random'
    ! field using real data that has mostly non-zero values.
    do i = 1, nummr
      call invoke( &
           setval_X( r_mr(i), theta ), &
           inc_a_times_X( 0.000001_r_def, r_mr(i) ), &
           setval_X( ls_mr(i), ls_theta ), &
           inc_a_times_X( 0.000001_r_def, ls_mr(i) ))
    end do

    ! Set the prognostic fields to be the linearisation state
    call invoke( setval_X( u, ls_u ),                     &
                 setval_X( theta, ls_theta ),             &
                 setval_X( rho, ls_rho ),                 &
                 setval_X( exner, ls_exner ) )

    do i = 1, num_moist_factors
      call invoke( setval_X( moist_dyn(i), ls_moist_dyn(i) ) )
    end do
    do i = 1, nummr
      call invoke( setval_X( mr(i), ls_mr(i) ) )
   end do

    call moist_dyn_factors_alg(moist_dyn, mr)

    ! Clean up solvers left over from previous tests, as semi-implicit
    ! method will create new solvers which cause double-allocates
    call final_si_operators()
    call semi_implicit_solver_alg_final()

    ! Set initial conditions equal to the linearisation state. This
    ! will be used to calculate the evolved baseline b_x = N(ls_x)
    allocate( semi_implicit_timestep_method, source=semi_implicit_timestep_type(modeldb) )
    call semi_implicit_timestep_method%step( modeldb )
    call semi_implicit_timestep_method%finalise()
    deallocate( semi_implicit_timestep_method )

    ! Save results from timestep execution
    call invoke( setval_X( b_u, u ),                     &
                 setval_X( b_theta, theta ),             &
                 setval_X( b_rho, rho ),                 &
                 setval_X( b_exner, exner ) )

    do i = 1, num_moist_factors
      call invoke( setval_X( b_moist_dyn(i), moist_dyn(i) ) )
    end do
    do i = 1, nummr
      call invoke( setval_X( b_mr(i), mr(i) ) )
    end do

    gamma_u = 6.5_r_def
    gamma_theta = 6.5_r_def
    gamma_rho = 6.5_r_def
    gamma_exner = 6.5_r_def

    if ( moisture_formulation == moisture_formulation_dry ) then
      gamma_mr = 0.0_r_def
    else
      gamma_mr = 6.5_r_def
    end if

    do n=1,2

      gamma_u = gamma_u / 2.0_r_def
      gamma_theta = gamma_theta / 2.0_r_def
      gamma_rho = gamma_rho / 2.0_r_def
      gamma_exner = gamma_exner / 2.0_r_def
      gamma_mr = gamma_mr / 2.0_r_def

      ! Compute perturbation fields, and also add them to nonlinear fields
      ! to set initial conditions equal to the perturbed linearisation
      ! state. This will be used to calculate x=N(ls_x + gamma r_x)
      call invoke( a_times_X( p_u, gamma_u, r_u ),              &
                   a_times_X( p_theta, gamma_theta, r_theta ),  &
                   a_times_X( p_rho, gamma_rho, r_rho ),        &
                   a_times_X( p_exner, gamma_exner, r_exner ),  &
                   setval_X( u, ls_u ),                     &
                   setval_X( theta, ls_theta ),             &
                   setval_X( rho, ls_rho ),                 &
                   setval_X( exner, ls_exner ),             &
                   inc_X_plus_Y( u, p_u ),                  &
                   inc_X_plus_Y( theta, p_theta ),          &
                   inc_X_plus_Y( rho, p_rho ),              &
                   inc_X_plus_Y( exner, p_exner ) )

      do i = 1, nummr
        call invoke( &
          a_times_X( p_mr(i), gamma_mr, r_mr(i) ), &
          setval_X( mr(i), ls_mr(i) ),                       &
          inc_X_plus_Y( mr(i), p_mr(i) ) )
      end do

      call moist_dyn_factors_alg(moist_dyn, mr)

      call tl_moist_dyn_factors_alg(p_moist_dyn, p_mr )

      ! Evolve u, theta, rho, exner and moist_dyn
      allocate( semi_implicit_timestep_method, source=semi_implicit_timestep_type(modeldb) )
      call semi_implicit_timestep_method%step( modeldb )
      call semi_implicit_timestep_method%finalise()
      deallocate( semi_implicit_timestep_method )

      ! Evolve the perturbation fields with the linear timestep. This
      ! gives p_x=L(gamma r_x)
      call final_si_operators()
      call tl_semi_implicit_alg_final()
      call tl_semi_implicit_alg_init(mesh, p_u, p_rho, p_theta, p_exner,     &
                                     p_mr, ls_u, ls_rho, ls_theta, ls_exner, &
                                     ls_mr, ls_moist_dyn)

      call tl_semi_implicit_alg_step(modeldb, p_u, p_rho, p_theta,   &
                                     p_exner, p_mr, p_moist_dyn,     &
                                     ls_u, ls_rho, ls_theta,         &
                                     ls_exner, ls_mr, ls_moist_dyn,  &
                                     derived_fields,                 &
                                     mesh, twod_mesh )

      call tl_semi_implicit_alg_final()

      ! Analyse the results: calculate the differences diff_x = x -
      ! b_x - p_x = N(ls_x + gamma_x) - N(ls_x) - L(gamma r_x)
      call invoke( X_minus_Y( diff_u, u, b_u ),                      &
                   inc_X_minus_Y( diff_u, p_u ),                     &
                   X_innerproduct_X( norm_u, diff_u ) )
      call invoke( X_minus_Y( diff_rho, rho, b_rho ),                &
                   inc_X_minus_Y( diff_rho, p_rho ),                 &
                   X_innerproduct_X( norm_rho, diff_rho ) )
      call invoke( X_minus_Y( diff_exner, exner, b_exner ),          &
                   inc_X_minus_Y( diff_exner, p_exner ),             &
                   X_innerproduct_X( norm_exner, diff_exner ) )
      call invoke( X_minus_Y( diff_theta, theta, b_theta ),          &
                   inc_X_minus_Y( diff_theta, p_theta ),             &
                   X_innerproduct_X( norm_theta, diff_theta ) )

      norm_mr=0.0_r_def
      do i = 1, nummr
        call invoke( &
          X_minus_Y( diff_mr(i), mr(i), b_mr(i) ),   &
          inc_X_minus_Y( diff_mr(i), p_mr(i) ),             &
          X_innerproduct_X( norm_mr_tmp, diff_mr(i) ) )
          norm_mr = norm_mr + norm_mr_tmp
      end do

      array_norm(1) = norm_u
      array_norm(2) = norm_rho
      array_norm(3) = norm_theta
      array_norm(4) = norm_mr
      array_norm(5) = norm_exner
      array_names(1) = 'norm_u'
      array_names(2) = 'norm_rho'
      array_names(3) = 'norm_theta'
      array_names(4) = 'norm_mr'
      array_names(5) = 'norm_exner'

      if (n == 2) then
        call array_convergence_rate_check( array_norm, array_norm_prev, &
             array_names, n_variables, label, tol=tol, indiv_tol=indiv_tol )
      end if

      array_norm_prev = array_norm

    end do

  end subroutine test_semi_imp_alg

end module tl_test_semi_imp_alg_mod
