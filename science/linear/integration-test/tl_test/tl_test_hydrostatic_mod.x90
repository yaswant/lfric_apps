!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief   The tangent linear test for the hydrostatic kernel
!!         (Taylor remainder convergence).
!>@details Test whether a section of tangent linear code is tangent linear
!!         to the corresponding section of nonlinear code, for the
!!         hydrostatic kernel, using the Taylor remainder convergence test.
module tl_test_hydrostatic_mod

  use sci_assign_field_random_kernel_mod, only: assign_field_random_kernel_type
  use constants_mod,                  only: i_def, r_def, str_def
  use dycore_constants_mod,           only: get_geopotential
  use sci_fem_constants_mod,          only: get_qr_fe
  use field_array_mod,                only: field_array_type
  use sci_field_bundle_builtins_mod,  only: clone_bundle
  use field_mod,                      only: field_type
  use field_collection_mod,           only: field_collection_type
  use finite_element_config_mod,      only: element_order_h, element_order_v
  use fs_continuity_mod,              only: W2, W3, Wtheta
  use function_space_collection_mod,  only: function_space_collection
  use driver_modeldb_mod,             only: modeldb_type
  use moist_dyn_mod,                  only: num_moist_factors
  use planet_config_mod,              only: cp
  use quadrature_xyoz_mod,            only: quadrature_xyoz_type
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO
  use mesh_mod,                       only: mesh_type
  use hydrostatic_kernel_mod,         only: hydrostatic_kernel_type
  use tl_hydrostatic_kernel_mod,      only: tl_hydrostatic_kernel_type
  use tl_test_convergence_rate_check, only: convergence_rate_check

  implicit none

  private
  public test_hydrostatic

  contains

  !> @brief Test the tangent linear hydrostatic kernel.
  !> @param[in] modeldb    The working data set for a model run
  !> @param[in] mesh       The current 3d mesh
  !> @param[in] twod_mesh  The current 2d mesh
  subroutine test_hydrostatic( modeldb, &
                               mesh,    &
                               twod_mesh )
    implicit none

    type(mesh_type), pointer, intent(in) :: mesh
    type(mesh_type), pointer, intent(in) :: twod_mesh

    type(modeldb_type), target, intent(in) :: modeldb

    character(str_def) :: label = "hydrostatic"

    type(field_collection_type ), pointer :: prognostic_fields => null()
    type(field_collection_type ), pointer :: ls_fields

    type( quadrature_xyoz_type ), pointer :: qr => null()
    type(field_type), pointer :: geopotential => null()

   ! Input
    type(field_type), pointer :: n_theta => null()  ! Nonlinear: x + gamma x'
    type(field_type), pointer :: ls_theta => null() ! Linearisation state: x
    type(field_type) :: p_theta                     ! Perturbed: gamma x'
    type(field_type), pointer :: n_exner => null()  ! Nonlinear: x + gamma x'
    type(field_type), pointer :: ls_exner => null() ! Linearisation state: x
    type(field_type) :: p_exner                     ! Perturbed: gamma x'
    type(field_type), pointer :: n_moist_dyn(:) => null()
    type(field_type), pointer :: ls_moist_dyn(:) => null()
    type(field_type), dimension(num_moist_factors) :: p_moist_dyn

    ! Output
    type(field_type) :: n1_rhs_u ! N( x )
    type(field_type) :: n2_rhs_u ! N( x + gamma x' )
    type(field_type) :: p_rhs_u  ! L( gamma x' )

    ! Test
    type(field_type) :: diff     ! N( x + gamma x' ) - N( x ) - L( gamma x' )
    type(field_type) :: random_theta ! x'
    type(field_type) :: random_exner ! x'
    type(field_type), dimension(num_moist_factors) :: random_moist_dyn ! x'

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: moist_dyn_array => null()
    type(field_array_type), pointer      :: ls_moist_dyn_array => null()

    real(r_def) :: norm_diff, norm_diff_prev
    real(r_def) :: gamma

    integer :: n, i
    real(r_def), parameter :: tol = 1.e-3_r_def

    call log_event( "TL Test: " // trim(label), &
                     LOG_LEVEL_INFO )

    qr => get_qr_fe()
    geopotential => get_geopotential(mesh%get_id())

    prognostic_fields => modeldb%fields%get_field_collection( &
                                           "prognostic_fields")

    ls_fields => modeldb%fields%get_field_collection("ls_fields")

    ! Input fields
    call prognostic_fields%get_field('theta', n_theta)
    call ls_fields%get_field('ls_theta', ls_theta)
    call p_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, Wtheta) )

    call prognostic_fields%get_field('exner', n_exner)
    call ls_fields%get_field('ls_exner', ls_exner)
    call p_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("moist_dyn", moist_dyn_array)
    n_moist_dyn => moist_dyn_array%bundle
    call moisture_fields%get_field("ls_moist_dyn", ls_moist_dyn_array)
    ls_moist_dyn => ls_moist_dyn_array%bundle

    call clone_bundle(n_moist_dyn, p_moist_dyn, num_moist_factors)

    ! Output fields
    call n1_rhs_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W2) )
    call n2_rhs_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W2) )
    call p_rhs_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W2) )

    ! Test fields
    call random_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, Wtheta) )
    call random_exner%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W3) )

    call clone_bundle(n_moist_dyn, random_moist_dyn, num_moist_factors)
    call diff%initialise( vector_space = &
      function_space_collection%get_fs(mesh, element_order_h, element_order_v, W2) )

    ! Taylor Remainder Convergence Test
    call invoke( setval_C( n1_rhs_u, 0.0_r_def ) )
    call invoke( hydrostatic_kernel_type( n1_rhs_u,            &
                                          ls_exner, ls_theta,  &
                                          ls_moist_dyn, geopotential, cp, qr ) )

    call invoke( assign_field_random_kernel_type( random_exner, 1.0_r_def ), &
                 assign_field_random_kernel_type( random_theta, 1.0_r_def ) )

    do i = 1, num_moist_factors
      call invoke( assign_field_random_kernel_type( random_moist_dyn(i), 1.0_r_def ) )
    end do

    gamma = 1.e10_r_def
    do n=1,2
      gamma = gamma / 2.0_r_def

      call invoke( setval_C( n2_rhs_u, 0.0_r_def ),           &
                   setval_C( p_rhs_u, 0.0_r_def ),            &
                   a_times_X( p_theta, gamma, random_theta ), &
                   setval_X( n_theta, ls_theta ),             &
                   inc_X_plus_Y( n_theta, p_theta ),          &
                   a_times_X( p_exner, gamma, random_exner ), &
                   setval_X( n_exner, ls_exner ),             &
                   inc_X_plus_Y( n_exner, p_exner ) )

      do i = 1, num_moist_factors
        call invoke( a_times_X( p_moist_dyn(i), gamma, random_moist_dyn(i) ), &
                     setval_X( n_moist_dyn(i), ls_moist_dyn(i) ),             &
                     inc_X_plus_Y( n_moist_dyn(i), p_moist_dyn(i) ) )
      end do

      call invoke( hydrostatic_kernel_type( n2_rhs_u,         &
                                            n_exner, n_theta, &
                                            n_moist_dyn,      &
                                            geopotential, cp, qr ) )
      call invoke( tl_hydrostatic_kernel_type( p_rhs_u,            &
                                               p_exner, p_theta,   &
                                               p_moist_dyn,        &
                                               ls_exner, ls_theta, &
                                               ls_moist_dyn,       &
                                               cp, qr ) )

      call invoke( X_minus_Y( diff, n2_rhs_u, n1_rhs_u ), &
                   inc_X_minus_Y( diff, p_rhs_u ),        &
                   X_innerproduct_X( norm_diff, diff ) )

      write( log_scratch_space, '(A, E32.12, A, E32.12)' ) &
             'gamma = ', gamma, ' norm = ', norm_diff

      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      if (n == 2) then
        call convergence_rate_check( norm_diff, norm_diff_prev, &
                                     label, tol=tol )
      end if

      norm_diff_prev = norm_diff
    end do

  end subroutine test_hydrostatic

end module tl_test_hydrostatic_mod
