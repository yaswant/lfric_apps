!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief
!>@details

module tl_test_rhs_alg_mod


  use constants_mod,                      only: i_def, r_def, str_def
  use driver_modeldb_mod,                 only: modeldb_type
  use field_array_mod,                    only: field_array_type
  use field_mod,                          only: field_type
  use mesh_mod,                           only: mesh_type
  use field_collection_mod,               only: field_collection_type
  use function_space_mod,                 only: function_space_type
  use derived_config_mod,                 only: bundle_size
  use moist_dyn_mod,                      only: num_moist_factors
  use mr_indices_mod,                     only: nummr
  use field_indices_mod,                  only: igh_u, igh_t, igh_d, igh_p
  use sci_field_bundle_builtins_mod,      only: clone_bundle,      &
                                                add_bundle,        &
                                                minus_bundle,      &
                                                set_bundle_scalar
  use timestepping_config_mod,            only: dt
  use rhs_alg_mod,                        only: rhs_alg
  use tl_rhs_alg_mod,                     only: tl_rhs_alg
  use log_mod,                            only: log_event, LOG_LEVEL_INFO, &
                                                LOG_LEVEL_ERROR
  use moist_dyn_factors_alg_mod,          only: moist_dyn_factors_alg
  use tl_moist_dyn_factors_alg_mod,       only: tl_moist_dyn_factors_alg
  use tl_test_convergence_rate_check,     only: array_convergence_rate_check

  implicit none

  private

  public :: test_rhs_alg

  contains

  !> @brief Tests the tangent linear model right-hand side algorithm
  !> @param[in] modedb    The working data set for a model run
  !> @param[in] mesh      The current 3d mesh
  !> @param[in] twod_mesh The current 2d mesh
  subroutine test_rhs_alg( modeldb, &
                           mesh,    &
                           twod_mesh )

    implicit none

    type(mesh_type), pointer, intent(in) :: mesh
    type(mesh_type), pointer, intent(in) :: twod_mesh

    type(modeldb_type), target, intent(in) :: modeldb

    character(str_def) :: label = "rhs_alg"

    type( field_collection_type ), pointer :: ls_fields
    type( field_collection_type ), pointer :: prognostic_fields => null()

    type( field_type ) :: state(bundle_size)
    type( field_type ) :: ls_state(bundle_size)
    type( field_type ) :: p_state(bundle_size)
    type( field_type ) :: random(bundle_size)
    type( field_type ) :: p_rhs(bundle_size)
    type( field_type ) :: n1_rhs(bundle_size)
    type( field_type ) :: n2_rhs(bundle_size)
    type( field_type ) :: diff(bundle_size)

    type(field_type), pointer :: ls_u => null()
    type(field_type), pointer :: ls_rho => null()
    type(field_type), pointer :: ls_theta => null()
    type(field_type), pointer :: ls_exner => null()
    type(field_type), pointer :: ls_moist_dyn(:) => null()
    type(field_type), pointer :: ls_mr(:) => null()
    type(field_type), pointer :: u => null()
    type(field_type), pointer :: rho => null()
    type(field_type), pointer :: theta => null()
    type(field_type), pointer :: exner => null()
    type(field_type), pointer :: moist_dyn(:) => null()
    type(field_type), pointer :: mr(:) => null()
    type(field_type), dimension(num_moist_factors) :: p_moist_dyn
    type(field_type), dimension(num_moist_factors) :: n_moist_dyn
    type(field_type), dimension(num_moist_factors) :: r_moist_dyn

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: mr_array => null()
    type(field_array_type), pointer      :: moist_dyn_array => null()
    type(field_array_type), pointer      :: ls_mr_array => null()
    type(field_array_type), pointer      :: ls_moist_dyn_array => null()

    real(r_def) :: gamma_u, gamma_rho, gamma_exner, gamma_theta, &
                   gamma_moist_dyn
    real(r_def) :: norm_u, norm_exner
    integer(i_def), parameter :: n_variables = 2
    real(r_def) :: array_norm(n_variables), array_norm_prev(n_variables)
    character(str_def) :: array_names(n_variables)

    real(r_def), parameter :: tol = 5.e-2_r_def
    real(r_def), parameter :: indiv_tol = 5.e-1_r_def

    integer :: i, n

    call log_event( "TL Test: " // trim(label), &
                     LOG_LEVEL_INFO )

    prognostic_fields => modeldb%fields%get_field_collection( &
                                           "prognostic_fields")
    ls_fields => modeldb%fields%get_field_collection("ls_fields")
    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("mr", mr_array)
    call moisture_fields%get_field("moist_dyn", moist_dyn_array)
    mr => mr_array%bundle
    moist_dyn => moist_dyn_array%bundle
    call moisture_fields%get_field("ls_mr", ls_mr_array)
    call moisture_fields%get_field("ls_moist_dyn", ls_moist_dyn_array)
    ls_mr => ls_mr_array%bundle
    ls_moist_dyn => ls_moist_dyn_array%bundle

    ! Linearisation state
    call ls_fields%get_field('ls_u', ls_u)
    call ls_fields%get_field('ls_rho', ls_rho)
    call ls_fields%get_field('ls_theta', ls_theta)
    call ls_fields%get_field('ls_exner', ls_exner)

    ! Perturbation
    call prognostic_fields%get_field('u', u)
    call prognostic_fields%get_field('rho', rho)
    call prognostic_fields%get_field('theta', theta)
    call prognostic_fields%get_field('exner', exner)

    call ls_state(igh_u)%initialise( vector_space = ls_u%get_function_space() )
    call ls_state(igh_t)%initialise( vector_space = ls_theta%get_function_space() )
    call ls_state(igh_d)%initialise( vector_space = ls_rho%get_function_space() )
    call ls_state(igh_p)%initialise( vector_space = ls_exner%get_function_space() )
    call clone_bundle(ls_state, state, bundle_size)
    call clone_bundle(ls_state, p_state, bundle_size)
    call clone_bundle(ls_state, random, bundle_size)
    call clone_bundle(ls_state, p_rhs, bundle_size)
    call clone_bundle(ls_state, n1_rhs, bundle_size)
    call clone_bundle(ls_state, n2_rhs, bundle_size)
    call clone_bundle(ls_state, diff, bundle_size)

    call clone_bundle(ls_moist_dyn, p_moist_dyn, num_moist_factors)
    call clone_bundle(ls_moist_dyn, r_moist_dyn, num_moist_factors)
    call clone_bundle(ls_moist_dyn, n_moist_dyn, num_moist_factors)

    call invoke( name = "copy_fields_to_ls_state",   &
                 setval_X(ls_state(igh_u), ls_u    ), &
                 setval_X(ls_state(igh_t), ls_theta), &
                 setval_X(ls_state(igh_d), ls_rho  ), &
                 setval_X(ls_state(igh_p), ls_exner) )

    call moist_dyn_factors_alg(ls_moist_dyn, ls_mr)

    ! Set the 'random data' to be the perturbation
    call invoke( name = "copy_fields_to_state",   &
                 setval_X(random(igh_u), u    ), &
                 setval_X(random(igh_p), exner    ), &
                 setval_X(random(igh_t), theta), &
                 setval_X(random(igh_d), rho  ) )

    call tl_moist_dyn_factors_alg(r_moist_dyn, mr )

    gamma_u = 1.0_r_def
    gamma_theta = 1.0_r_def
    gamma_rho = 1.0_r_def
    gamma_exner = 1.0_r_def
    gamma_moist_dyn = 1.0_r_def

    call set_bundle_scalar( 0.0_r_def, n1_rhs, bundle_size )
    call rhs_alg( n1_rhs, dt, ls_state, ls_state, ls_moist_dyn, &
                  compute_eos=.true.,  compute_rhs_t_d=.true.,  &
                  dlayer_rhs=.true., model_clock=modeldb%clock )

    do n=1,2
      gamma_u = gamma_u / 2.0_r_def
      gamma_theta = gamma_theta / 2.0_r_def
      gamma_rho = gamma_rho / 2.0_r_def
      gamma_exner = gamma_exner / 2.0_r_def
      gamma_moist_dyn = gamma_moist_dyn / 2.0_r_def

      call set_bundle_scalar( 0.0_r_def, n2_rhs, bundle_size )
      call set_bundle_scalar( 0.0_r_def, p_rhs, bundle_size )
      call invoke( a_times_X( p_state(igh_u), gamma_u, random(igh_u) ),       &
                   a_times_X( p_state(igh_t), gamma_theta, random(igh_t) ),   &
                   a_times_X( p_state(igh_d), gamma_rho, random(igh_d) ),     &
                   a_times_X( p_state(igh_p), gamma_exner, random(igh_p) ) )

      ! state = ls_state + p_state
      call add_bundle( ls_state, p_state, state, bundle_size )

      do i = 1, num_moist_factors
        call invoke( &
          a_times_X( p_moist_dyn(i), gamma_moist_dyn, r_moist_dyn(i) ), &
          setval_X( n_moist_dyn(i), ls_moist_dyn(i) ),                  &
          inc_X_plus_Y( n_moist_dyn(i), p_moist_dyn(i) ) )
      enddo

      call rhs_alg( n2_rhs, dt, state, state, n_moist_dyn, &
                    compute_eos=.true., compute_rhs_t_d=.true., &
                    dlayer_rhs=.true., model_clock=modeldb%clock )

      call tl_rhs_alg(p_rhs, dt, p_state, p_state, p_moist_dyn, &
                      ls_state, ls_moist_dyn,                   &
                      compute_eos=.true., dlayer_rhs=.true.,   &
                      model_clock=modeldb%clock)

      ! diff = n2_rhs - n1_rhs
      call minus_bundle( n2_rhs, n1_rhs, diff, bundle_size )

      call invoke( &
                 inc_X_minus_Y( diff(igh_u), p_rhs(igh_u) ), &
                 inc_X_minus_Y( diff(igh_p), p_rhs(igh_p) ) )

      call invoke( X_innerproduct_X( norm_u,     diff(igh_u) ) , &
                   X_innerproduct_X( norm_exner, diff(igh_p) ) )

      ! The equations for rho and theta are already linear
      ! so only evaluate u and exner
      array_norm(1) = norm_u
      array_norm(2) = norm_exner
      array_names(1) = 'norm_u'
      array_names(2) = 'norm_exner'

      if (n == 2) then
        call array_convergence_rate_check( &
                   array_norm, array_norm_prev, &
                   array_names, n_variables, label, tol=tol, &
                   indiv_tol=indiv_tol )
      end if

      array_norm_prev = array_norm

    enddo

  end subroutine test_rhs_alg
end module tl_test_rhs_alg_mod
