!------------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!------------------------------------------------------------------------------
! @brief Calculate properties of tiles for radiative transfer

module rad_tile_alg_mod

use field_mod,                     only: field_type
use field_collection_mod,          only: field_collection_type
use function_space_collection_mod, only: function_space_collection
use function_space_mod,            only: function_space_type
use mesh_mod,                      only: mesh_type
use constants_mod,                 only: r_def, i_def
use empty_data_mod,                only: empty_real_data
use log_mod,                       only: log_event, &
                                         log_scratch_space, &
                                         LOG_LEVEL_ERROR
use timing_mod,                    only: start_timing, stop_timing, &
                                         tik, LPROF
use jules_control_init_mod,        only: n_surf_tile
use sci_geometric_constants_mod,   only: get_dz_at_wtheta
use fs_continuity_mod,             only: W3, Wtheta
use radiation_config_mod,          only: l_planet_grey_surface, &
                                         planet_emissivity, planet_albedo, &
                                         n_radstep, &
                                         l_inc_radstep, n_inc_radstep
use section_choice_config_mod,     only: surface, surface_jules, radiation, &
                                         radiation_socrates

use socrates_init_mod, only: wavelength_short, wavelength_long, &
  n_band_exclude, index_exclude, weight_blue, &
  n_sw_band, sw_wavelength_short, sw_wavelength_long, sw_weight_blue, &
  n_swinc_band, swinc_wavelength_short, swinc_wavelength_long, &
  swinc_weight_blue, &
  n_lw_band, lw_wavelength_short, lw_wavelength_long, &
  lw_n_band_exclude, lw_index_exclude, &
  n_lwinc_band, lwinc_wavelength_short, lwinc_wavelength_long, &
  lwinc_n_band_exclude, lwinc_index_exclude

use sw_rad_tile_kernel_mod, only: sw_rad_tile_kernel_type
use lw_rad_tile_kernel_mod, only: lw_rad_tile_kernel_type

implicit none
private

!------------------------------------------------------------------------------
! Contained functions/subroutines
!------------------------------------------------------------------------------
public :: rad_tile_alg

contains

! @param[in,out] tile_sw_direct_albedo  Tile SW direct albedos
! @param[in,out] tile_sw_diffuse_albedo Tile SW diffuse albedos
! @param[in,out] tile_swinc_direct_albedo  Tile SWINC direct albedos
! @param[in,out] tile_swinc_diffuse_albedo Tile SWINC diffuse albedos
! @param[in,out] tile_lw_albedo         Tile LW albedos (1 - emissivity)
! @param[in,out] tile_lwinc_albedo      Tile LWINC albedos (1 - emissivity)
! @param[in]     derived_fields         Derived fields
! @param[in,out] radiation_fields       Fields for radiation scheme
! @param[in]     orography_fields       Fields for orog drag scheme
! @param[in,out] surface_fields         Fields for surface scheme
! @param[in]     soil_fields            Fields for soil hydrology scheme
! @param[in]     snow_fields            Fields for snow scheme
! @param[in]     twod_mesh              Current 2d mesh
! @param[in]     timestep               Current timestep number
subroutine rad_tile_alg(tile_sw_direct_albedo, tile_sw_diffuse_albedo,       &
                        tile_swinc_direct_albedo, tile_swinc_diffuse_albedo, &
                        tile_lw_albedo, tile_lwinc_albedo, derived_fields,   &
                        radiation_fields, orography_fields,                  &
                        surface_fields, soil_fields, snow_fields,            &
                        twod_mesh, timestep)

  implicit none

  type( field_type ), intent( inout ) :: tile_sw_direct_albedo
  type( field_type ), intent( inout ) :: tile_sw_diffuse_albedo
  type( field_type ), intent( inout ) :: tile_swinc_direct_albedo
  type( field_type ), intent( inout ) :: tile_swinc_diffuse_albedo
  type( field_type ), intent( inout ) :: tile_lw_albedo
  type( field_type ), intent( inout ) :: tile_lwinc_albedo
  type( field_collection_type ), intent(in)    :: derived_fields
  type( field_collection_type ), intent(inout) :: radiation_fields
  type( field_collection_type ), intent(in)    :: orography_fields
  type( field_collection_type ), intent(inout) :: surface_fields
  type( field_collection_type ), intent(in)    :: soil_fields
  type( field_collection_type ), intent(in)    :: snow_fields
  type( mesh_type ), pointer,    intent(in)    :: twod_mesh
  integer( kind=i_def ),         intent(in)    :: timestep

  ! Unpacked fields from collections
  type( field_type ), pointer :: sd_orog           => null()

  type( field_type ), pointer :: tile_fraction     => null()
  type( field_type ), pointer :: leaf_area_index   => null()
  type( field_type ), pointer :: canopy_height     => null()
  type( field_type ), pointer :: tile_temperature  => null()
  type( field_type ), pointer :: tile_lw_grey_albedo => null()
  type( field_type ), pointer :: albedo_obs_scaling => null()
  type( field_type ), pointer :: chloro_sea        => null()
  type( field_type ), pointer :: sea_ice_thickness => null()
  type( field_type ), pointer :: melt_pond_fraction => null()
  type( field_type ), pointer :: melt_pond_depth   => null()
  type( field_type ), pointer :: sea_ice_pensolar_frac_direct => null()
  type( field_type ), pointer :: sea_ice_pensolar_frac_diffuse => null()
  type( field_type ), pointer :: z0msea            => null()
  type( field_type ), pointer :: urbhwr            => null()
  type( field_type ), pointer :: urbztm            => null()
  type( field_type ), pointer :: urbalbwl          => null()
  type( field_type ), pointer :: urbalbrd          => null()
  type( field_type ), pointer :: urbemisc

  type( field_type ), pointer :: soil_albedo       => null()
  type( field_type ), pointer :: soil_roughness    => null()

  type( field_type ), pointer :: albedo_obs_vis    => null()
  type( field_type ), pointer :: albedo_obs_nir    => null()
  type( field_type ), pointer :: cos_zenith_angle_rts => null()

  type( field_type ), pointer :: tile_snow_mass    => null()
  type( field_type ), pointer :: tile_snow_rgrain  => null()
  type( field_type ), pointer :: snow_depth        => null()
  type( field_type ), pointer :: snowpack_density  => null()
  type( field_type ), pointer :: snow_soot         => null()

  type( field_type ), pointer :: u_in_w3          => null()
  type( field_type ), pointer :: v_in_w3          => null()

  type( field_type ), pointer :: dz_wth            => null()

  ! Pointers to vector spaces
  type(function_space_type), pointer :: vector_space => null()

  ! Grey LW surface albedo
  real( kind=r_def ) :: planet_lw_albedo
  integer( tik )     :: id

  if ( LPROF ) call start_timing( id, 'jules.radiation' )

  vector_space => function_space_collection%get_fs( &
                    twod_mesh, 0, 0, W3, n_sw_band * n_surf_tile )
  call tile_sw_direct_albedo%initialise(vector_space)
  call tile_sw_diffuse_albedo%initialise(vector_space)

  vector_space => function_space_collection%get_fs( &
                    twod_mesh, 0, 0, W3, n_lw_band * n_surf_tile )
  call tile_lw_albedo%initialise(vector_space)

  call surface_fields%get_field('tile_lw_grey_albedo', tile_lw_grey_albedo)

  if (radiation == radiation_socrates .and. l_inc_radstep) then
    ! Radiation increments use different spectral files with fewer bands
    vector_space => function_space_collection%get_fs( &
                      twod_mesh, 0, 0, W3, n_swinc_band * n_surf_tile )
    call tile_swinc_direct_albedo%initialise(vector_space)
    call tile_swinc_diffuse_albedo%initialise(vector_space)

    vector_space => function_space_collection%get_fs( &
                      twod_mesh, 0, 0, W3, n_lwinc_band * n_surf_tile )
    call tile_lwinc_albedo%initialise(vector_space)
  else
    vector_space => function_space_collection%get_fs( twod_mesh, 0, 0, W3, 1)
    call tile_swinc_direct_albedo%initialise( &
      vector_space, override_data = empty_real_data )
    call tile_swinc_diffuse_albedo%initialise( &
      vector_space, override_data = empty_real_data )
    call tile_lwinc_albedo%initialise( &
      vector_space, override_data = empty_real_data )
  end if

  if (l_planet_grey_surface) then

    planet_lw_albedo = 1.0_r_def - planet_emissivity
    call invoke(setval_c(tile_sw_direct_albedo,  planet_albedo), &
                setval_c(tile_sw_diffuse_albedo, planet_albedo), &
                setval_c(tile_lw_albedo,         planet_lw_albedo), &
                setval_c(tile_lw_grey_albedo,    planet_lw_albedo))
    if (radiation == radiation_socrates .and. l_inc_radstep) then
     call invoke(setval_c(tile_swinc_direct_albedo,  planet_albedo), &
                 setval_c(tile_swinc_diffuse_albedo, planet_albedo), &
                 setval_c(tile_lwinc_albedo,         planet_lw_albedo))
    end if

  else if (surface == surface_jules) then

    call orography_fields%get_field('sd_orog', sd_orog)

    call surface_fields%get_field('tile_fraction', tile_fraction)
    call surface_fields%get_field('leaf_area_index', leaf_area_index)
    call surface_fields%get_field('canopy_height', canopy_height)
    call surface_fields%get_field('tile_temperature', tile_temperature)
    call surface_fields%get_field('albedo_obs_scaling', albedo_obs_scaling)
    call surface_fields%get_field('chloro_sea', chloro_sea)
    call surface_fields%get_field('sea_ice_thickness', sea_ice_thickness)
    call surface_fields%get_field('melt_pond_fraction', melt_pond_fraction)
    call surface_fields%get_field('melt_pond_depth', melt_pond_depth)
    call surface_fields%get_field('sea_ice_pensolar_frac_direct', sea_ice_pensolar_frac_direct)
    call surface_fields%get_field('sea_ice_pensolar_frac_diffuse', sea_ice_pensolar_frac_diffuse)
    call surface_fields%get_field('z0msea', z0msea)
    call surface_fields%get_field('urbhwr', urbhwr)
    call surface_fields%get_field('urbztm', urbztm)
    call surface_fields%get_field('urbalbwl', urbalbwl)
    call surface_fields%get_field('urbalbrd', urbalbrd)
    call surface_fields%get_field('urbemisc', urbemisc)

    call soil_fields%get_field('soil_albedo', soil_albedo)
    call soil_fields%get_field('soil_roughness', soil_roughness)

    call radiation_fields%get_field('albedo_obs_vis', albedo_obs_vis)
    call radiation_fields%get_field('albedo_obs_nir', albedo_obs_nir)
    call radiation_fields%get_field('cos_zenith_angle_rts', cos_zenith_angle_rts)

    call snow_fields%get_field('tile_snow_mass', tile_snow_mass)
    call snow_fields%get_field('tile_snow_rgrain', tile_snow_rgrain)
    call snow_fields%get_field('snow_depth', snow_depth)
    call snow_fields%get_field('snowpack_density', snowpack_density)
    call snow_fields%get_field('snow_soot', snow_soot)

    call derived_fields%get_field('u_in_w3', u_in_w3)
    call derived_fields%get_field('v_in_w3', v_in_w3)

    dz_wth            => get_dz_at_wtheta(u_in_w3%get_mesh_id())

    ! SW albedos only required on radiation timesteps
    if (radiation == radiation_socrates .and. &
         mod(timestep-1_i_def, n_radstep) == 0) then
      ! Scalar arrays passed through module scope until kernels can handle them
      wavelength_short => sw_wavelength_short
      wavelength_long => sw_wavelength_long
      weight_blue => sw_weight_blue
      call invoke(sw_rad_tile_kernel_type( &
        tile_sw_direct_albedo, tile_sw_diffuse_albedo, &
        tile_fraction, leaf_area_index, canopy_height, &
        sd_orog, soil_albedo, soil_roughness, &
        albedo_obs_vis, albedo_obs_nir, albedo_obs_scaling, &
        tile_temperature, tile_snow_mass, tile_snow_rgrain, &
        snow_depth, snowpack_density, snow_soot, &
        chloro_sea, sea_ice_thickness, &
        melt_pond_fraction, melt_pond_depth, &
        sea_ice_pensolar_frac_direct, sea_ice_pensolar_frac_diffuse,  &
        u_in_w3, v_in_w3, dz_wth, z0msea, &
        cos_zenith_angle_rts, urbhwr, urbztm, urbalbwl, urbalbrd, &
        n_sw_band))
    end if

    if (radiation == radiation_socrates .and. l_inc_radstep) then
      ! Albedos required on different bands for the radiation increments
      if (mod(timestep-1_i_def, n_inc_radstep) == 0) then
        wavelength_short => swinc_wavelength_short
        wavelength_long => swinc_wavelength_long
        weight_blue => swinc_weight_blue
        call invoke(sw_rad_tile_kernel_type( &
          tile_swinc_direct_albedo, tile_swinc_diffuse_albedo, &
          tile_fraction, leaf_area_index, canopy_height, &
          sd_orog, soil_albedo, soil_roughness, &
          albedo_obs_vis, albedo_obs_nir, albedo_obs_scaling, &
          tile_temperature, tile_snow_mass, tile_snow_rgrain, &
          snow_depth, snowpack_density, snow_soot, &
          chloro_sea, sea_ice_thickness, &
          melt_pond_fraction, melt_pond_depth, &
          sea_ice_pensolar_frac_direct, sea_ice_pensolar_frac_diffuse,  &
          u_in_w3, v_in_w3, dz_wth, z0msea, &
          cos_zenith_angle_rts, urbhwr, urbztm, urbalbwl, urbalbrd, &
          n_swinc_band))

        wavelength_short => lwinc_wavelength_short
        wavelength_long => lwinc_wavelength_long
        n_band_exclude => lwinc_n_band_exclude
        index_exclude => lwinc_index_exclude
        call invoke(lw_rad_tile_kernel_type(tile_lwinc_albedo, &
                                            tile_lw_grey_albedo, &
                                            tile_fraction, &
                                            tile_temperature, &
                                            tile_snow_mass, &
                                            leaf_area_index, &
                                            canopy_height, &
                                            soil_roughness, &
                                            urbztm, &
                                            urbemisc, &
                                            n_lwinc_band))
      end if
    end if

    ! LW albedos always required
    wavelength_short => lw_wavelength_short
    wavelength_long => lw_wavelength_long
    n_band_exclude => lw_n_band_exclude
    index_exclude => lw_index_exclude
    call invoke(lw_rad_tile_kernel_type(tile_lw_albedo, &
                                        tile_lw_grey_albedo, &
                                        tile_fraction, &
                                        tile_temperature, &
                                        tile_snow_mass, &
                                        leaf_area_index, &
                                        canopy_height, &
                                        soil_roughness, &
                                        urbztm, &
                                        urbemisc, &
                                        n_lw_band))

  else
    write( log_scratch_space, '(A)' ) &
    'rad_tile_alg_mod: When JULES is not used, set l_planet_grey_surface=.true.'
    call log_event( log_scratch_space, LOG_LEVEL_ERROR )
  end if

  if ( LPROF ) call stop_timing( id, 'jules.radiation' )

end subroutine rad_tile_alg
end module rad_tile_alg_mod
